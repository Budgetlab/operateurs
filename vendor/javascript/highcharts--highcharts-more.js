var G=typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:global;var F={};!function(G){F?(G.default=G,F=G):G("undefined"!=typeof Highcharts?Highcharts:void 0)}((function(F){var H=F?F._modules:{};function i(G,F,H,U){G.hasOwnProperty(F)||(G[F]=U.apply(null,H),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:F,module:G[F]}})))}i(H,"Extensions/Pane/PaneComposition.js",[H["Core/Globals.js"],H["Core/Utilities.js"]],(function(F,H){let{composed:U}=F,{addEvent:q,correctFloat:V,defined:K,pick:Z,pushUnique:_}=H;function l(F){let H;let U=this||G;return F&&U.pane.forEach((G=>{let q=F.chartX-U.plotLeft,V=F.chartY-U.plotTop;h(q,V,G.center)&&(H=G)})),H}function h(G,F,H,U,q){let Z=!0,_=H[0],Q=H[1],$=Math.sqrt(Math.pow(G-_,2)+Math.pow(F-Q,2));if(K(U)&&K(q)){let H=Math.atan2(V(F-Q,8),V(G-_,8));q!==U&&(Z=U>q?H>=U&&H<=Math.PI||H<=q&&H>=-Math.PI:H>=U&&H<=V(q,8))}return $<=Math.ceil(H[2]/2)&&Z}function p(F){(this||G).polar&&(F.options.inverted&&([F.x,F.y]=[F.y,F.x]),F.isInsidePlot=(this||G).pane.some((G=>h(F.x,F.y,G.center,G.axis&&G.axis.normalizedStartAngleRad,G.axis&&G.axis.normalizedEndAngleRad))))}function d(F){let H=(this||G).chart;F.hoverPoint&&F.hoverPoint.plotX&&F.hoverPoint.plotY&&H.hoverPane&&!h(F.hoverPoint.plotX,F.hoverPoint.plotY,H.hoverPane.center)&&(F.hoverPoint=void 0)}function c(F){let H=(this||G).chart;H.polar?(H.hoverPane=H.getHoverPane(F),F.filter=function(G){return G.visible&&!(!F.shared&&G.directTouch)&&Z(G.options.enableMouseTracking,!0)&&(!H.hoverPane||G.xAxis.pane===H.hoverPane)}):H.hoverPane=void 0}return{compose:function t(G,F){if(_(U,t)){let H=G.prototype;H.collectionsWithUpdate.push("pane"),H.getHoverPane=l,q(G,"afterIsInsidePlot",p),q(F,"afterGetHoverData",d),q(F,"beforeGetHoverData",c)}}}})),i(H,"Extensions/Pane/PaneDefaults.js",[],(function(){let G={shape:"circle",borderWidth:1,borderColor:"#cccccc",backgroundColor:{linearGradient:{x1:0,y1:0,x2:0,y2:1},stops:[[0,"#ffffff"],[1,"#e6e6e6"]]},from:-Number.MAX_VALUE,innerRadius:0,to:Number.MAX_VALUE,outerRadius:"105%"};return{pane:{center:["50%","50%"],size:"85%",innerSize:"0%",startAngle:0},background:G}})),i(H,"Extensions/Pane/Pane.js",[H["Series/CenteredUtilities.js"],H["Extensions/Pane/PaneComposition.js"],H["Extensions/Pane/PaneDefaults.js"],H["Core/Utilities.js"]],(function(G,F,H,U){let{extend:q,merge:V,splat:K}=U;class n{constructor(G,F){this.coll="pane",this.init(G,F)}init(G,F){this.chart=F,this.background=[],F.pane.push(this),this.setOptions(G)}setOptions(G){this.options=G=V(H.pane,this.chart.angular?{background:{}}:void 0,G)}render(){let G=this.options,F=this.chart.renderer;this.group||(this.group=F.g("pane-group").attr({zIndex:G.zIndex||0}).add()),this.updateCenter();let U=this.options.background;if(U){U=K(U);let G=Math.max(U.length,this.background.length||0);for(let F=0;F<G;F++)U[F]&&this.axis?this.renderBackground(V(H.background,U[F]),F):this.background[F]&&(this.background[F]=this.background[F].destroy(),this.background.splice(F,1))}}renderBackground(G,F){let H={class:"highcharts-pane "+(G.className||"")},U="animate";this.chart.styledMode||q(H,{fill:G.backgroundColor,stroke:G.borderColor,"stroke-width":G.borderWidth}),this.background[F]||(this.background[F]=this.chart.renderer.path().add(this.group),U="attr"),this.background[F][U]({d:this.axis.getPlotBandPath(G.from,G.to,G)}).attr(H)}updateCenter(F){this.center=(F||this.axis||{}).center=G.getCenter.call(this)}update(G,F){V(!0,this.options,G),this.setOptions(this.options),this.render(),this.chart.axes.forEach((function(G){G.pane===this&&(G.pane=null,G.update({},F))}),this)}}return n.compose=F.compose,n})),i(H,"Series/AreaRange/AreaRangePoint.js",[H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F){let{area:{prototype:{pointClass:H,pointClass:{prototype:U}}}}=G.seriesTypes,{defined:q,isNumber:V,merge:K}=F;return class extends H{setState(){let G=this.state,F=this.series,H=F.chart.polar;F.options.marker,F.symbol,q(this.plotHigh)||(this.plotHigh=F.yAxis.toPixels(this.high,!0)),q(this.plotLow)||(this.plotLow=this.plotY=F.yAxis.toPixels(this.low,!0)),F.lowerStateMarkerGraphic=F.stateMarkerGraphic,F.stateMarkerGraphic=F.upperStateMarkerGraphic,this.graphic=this.graphics&&this.graphics[1],this.plotY=this.plotHigh,H&&V(this.plotHighX)&&(this.plotX=this.plotHighX),U.setState.apply(this,arguments),this.state=G,this.plotY=this.plotLow,this.graphic=this.graphics&&this.graphics[0],H&&V(this.plotLowX)&&(this.plotX=this.plotLowX),F.upperStateMarkerGraphic=F.stateMarkerGraphic,F.stateMarkerGraphic=F.lowerStateMarkerGraphic,F.lowerStateMarkerGraphic=void 0;let K=F.modifyMarkerSettings();U.setState.apply(this,arguments),F.restoreMarkerSettings(K)}haloPath(){let G=this.series.chart.polar,F=[];return this.plotY=this.plotLow,G&&V(this.plotLowX)&&(this.plotX=this.plotLowX),this.isInside&&(F=U.haloPath.apply(this,arguments)),this.plotY=this.plotHigh,G&&V(this.plotHighX)&&(this.plotX=this.plotHighX),this.isTopInside&&(F=F.concat(U.haloPath.apply(this,arguments))),F}isValid(){return V(this.low)&&V(this.high)}}})),i(H,"Series/AreaRange/AreaRangeSeries.js",[H["Series/AreaRange/AreaRangePoint.js"],H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(F,H,U,q){let{noop:V}=H,{area:K,area:{prototype:Z},column:{prototype:_}}=U.seriesTypes,{addEvent:Q,defined:$,extend:J,isArray:tt,isNumber:et,pick:it,merge:st}=q;class f extends K{toYData(G){return[G.low,G.high]}highToXY(G){let F=this.chart,H=this.xAxis.postTranslate(G.rectPlotX||0,this.yAxis.len-(G.plotHigh||0));G.plotHighX=H.x-F.plotLeft,G.plotHigh=H.y-F.plotTop,G.plotLowX=G.plotX}getGraphPath(G){let F,H,U,q=[],V=[],K=Z.getGraphPath,_=this.options,Q=this.chart.polar,$=Q&&!1!==_.connectEnds,J=_.connectNulls,tt=_.step;for(F=(G=G||this.points).length;F--;){H=G[F];let K=Q?{plotX:H.rectPlotX,plotY:H.yBottom,doCurve:!1}:{plotX:H.plotX,plotY:H.plotY,doCurve:!1};H.isNull||$||J||G[F+1]&&!G[F+1].isNull||V.push(K),U={polarPlotY:H.polarPlotY,rectPlotX:H.rectPlotX,yBottom:H.yBottom,plotX:it(H.plotHighX,H.plotX),plotY:H.plotHigh,isNull:H.isNull},V.push(U),q.push(U),H.isNull||$||J||G[F-1]&&!G[F-1].isNull||V.push(K)}let et=K.call(this,G);tt&&(!0===tt&&(tt="left"),_.step={left:"right",center:"center",right:"left"}[tt]);let st=K.call(this,q),ot=K.call(this,V);_.step=tt;let at=[].concat(et,st);return!this.chart.polar&&ot[0]&&"M"===ot[0][0]&&(ot[0]=["L",ot[0][1],ot[0][2]]),this.graphPath=at,this.areaPath=et.concat(ot),at.isArea=!0,at.xMap=et.xMap,this.areaPath.xMap=et.xMap,at}drawDataLabels(){let G,F,H,U,q;let V=this.points,K=V.length,_=[],Q=this.options.dataLabels,$=this.chart.inverted;if(Q){if(tt(Q)?(U=Q[0]||{enabled:!1},q=Q[1]||{enabled:!1}):((U=J({},Q)).x=Q.xHigh,U.y=Q.yHigh,(q=J({},Q)).x=Q.xLow,q.y=Q.yLow),U.enabled||this.hasDataLabels?.()){for(G=K;G--;)if(F=V[G]){let{plotHigh:q=0,plotLow:V=0}=F;H=U.inside?q<V:q>V,F.y=F.high,F._plotY=F.plotY,F.plotY=q,_[G]=F.dataLabel,F.dataLabel=F.dataLabelUpper,F.below=H,$?U.align||(U.align=H?"right":"left"):U.verticalAlign||(U.verticalAlign=H?"top":"bottom")}for(this.options.dataLabels=U,Z.drawDataLabels&&Z.drawDataLabels.apply(this,arguments),G=K;G--;)(F=V[G])&&(F.dataLabelUpper=F.dataLabel,F.dataLabel=_[G],delete F.dataLabels,F.y=F.low,F.plotY=F._plotY)}if(q.enabled||this.hasDataLabels?.()){for(G=K;G--;)if(F=V[G]){let{plotHigh:G=0,plotLow:U=0}=F;H=q.inside?G<U:G>U,F.below=!H,$?q.align||(q.align=H?"left":"right"):q.verticalAlign||(q.verticalAlign=H?"bottom":"top")}this.options.dataLabels=q,Z.drawDataLabels&&Z.drawDataLabels.apply(this,arguments)}if(U.enabled)for(G=K;G--;)(F=V[G])&&(F.dataLabels=[F.dataLabelUpper,F.dataLabel].filter((function(G){return!!G})));this.options.dataLabels=Q}}alignDataLabel(){_.alignDataLabel.apply(this,arguments)}modifyMarkerSettings(){let G={marker:this.options.marker,symbol:this.symbol};if(this.options.lowMarker){let{options:{marker:G,lowMarker:F}}=this;this.options.marker=st(G,F),F.symbol&&(this.symbol=F.symbol)}return G}restoreMarkerSettings(G){this.options.marker=G.marker,this.symbol=G.symbol}drawPoints(){let G,F;let H=this.points.length,U=this.modifyMarkerSettings();for(Z.drawPoints.apply(this,arguments),this.restoreMarkerSettings(U),G=0;G<H;)(F=this.points[G]).graphics=F.graphics||[],F.origProps={plotY:F.plotY,plotX:F.plotX,isInside:F.isInside,negative:F.negative,zone:F.zone,y:F.y},(F.graphic||F.graphics[0])&&(F.graphics[0]=F.graphic),F.graphic=F.graphics[1],F.plotY=F.plotHigh,$(F.plotHighX)&&(F.plotX=F.plotHighX),F.y=it(F.high,F.origProps.y),F.negative=F.y<(this.options.threshold||0),this.zones.length&&(F.zone=F.getZone()),this.chart.polar||(F.isInside=F.isTopInside=void 0!==F.plotY&&F.plotY>=0&&F.plotY<=this.yAxis.len&&F.plotX>=0&&F.plotX<=this.xAxis.len),G++;for(Z.drawPoints.apply(this,arguments),G=0;G<H;)(F=this.points[G]).graphics=F.graphics||[],(F.graphic||F.graphics[1])&&(F.graphics[1]=F.graphic),F.graphic=F.graphics[0],F.origProps&&(J(F,F.origProps),delete F.origProps),G++}hasMarkerChanged(G,F){let H=G.lowMarker,U=F.lowMarker||{};return H&&(!1===H.enabled||U.symbol!==H.symbol||U.height!==H.height||U.width!==H.width)||super.hasMarkerChanged(G,F)}}return f.defaultOptions=st(K.defaultOptions,{lineWidth:1,threshold:null,tooltip:{pointFormat:'<span style="color:{series.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},trackByArea:!0,dataLabels:{align:void 0,verticalAlign:void 0,xLow:0,xHigh:0,yLow:0,yHigh:0}}),Q(f,"afterTranslate",(function(){"low,high"===(this||G).pointArrayMap.join(",")&&(this||G).points.forEach((F=>{let H=F.high,U=F.plotY;F.isNull?F.plotY=void 0:(F.plotLow=U,F.plotHigh=et(H)?(this||G).yAxis.translate((this||G).dataModify?(this||G).dataModify.modifyValue(H):H,!1,!0,void 0,!0):void 0,(this||G).dataModify&&(F.yBottom=F.plotHigh))}))}),{order:0}),Q(f,"afterTranslate",(function(){(this||G).chart.inverted,(this||G).points.forEach((F=>{if((this||G).chart.polar)this.highToXY(F),F.plotLow=F.plotY,F.tooltipPos=[((F.plotHighX||0)+(F.plotLowX||0))/2,((F.plotHigh||0)+(F.plotLow||0))/2];else{let G=F.pos(!1,F.plotLow),H=F.pos(!1,F.plotHigh);G&&H&&(G[0]=(G[0]+H[0])/2,G[1]=(G[1]+H[1])/2),F.tooltipPos=G}}))}),{order:3}),J(f.prototype,{deferTranslatePolar:!0,pointArrayMap:["low","high"],pointClass:F,pointValKey:"low",setStackedPoints:V}),U.registerSeriesType("arearange",f),f})),i(H,"Series/AreaSplineRange/AreaSplineRangeSeries.js",[H["Series/AreaRange/AreaRangeSeries.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H){let{spline:{prototype:U}}=F.seriesTypes,{merge:q,extend:V}=H;class r extends G{}return r.defaultOptions=q(G.defaultOptions),V(r.prototype,{getPointSpline:U.getPointSpline}),F.registerSeriesType("areasplinerange",r),r})),i(H,"Series/BoxPlot/BoxPlotSeriesDefaults.js",[],(function(){return{threshold:null,tooltip:{pointFormat:'<span style="color:{point.color}">●</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'},whiskerLength:"50%",fillColor:"#ffffff",lineWidth:1,medianWidth:2,whiskerWidth:2}})),i(H,"Series/BoxPlot/BoxPlotSeries.js",[H["Series/BoxPlot/BoxPlotSeriesDefaults.js"],H["Series/Column/ColumnSeries.js"],H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H,U,q){let{noop:V}=H,{extend:K,merge:Z,pick:_}=q;class h extends F{pointAttribs(){return{}}translate(){let G=this.yAxis,F=this.pointArrayMap;super.translate.apply(this),this.points.forEach((function(H){F.forEach((function(F){null!==H[F]&&(H[F+"Plot"]=G.translate(H[F],0,1,0,1))})),H.plotHigh=H.highPlot}))}drawPoints(){let G,F,H,U,q,V,K,Z,Q,$,J,tt,et,it,st=this.points,ot=this.options,at=this.chart,rt=at.renderer,nt=!1!==this.doQuartiles,lt=this.options.whiskerLength,ht=0;for(let pt of st){Q=pt.graphic;let st=Q?"animate":"attr",dt=pt.shapeArgs,ct={},ut={},gt={},ft={},mt=pt.color||this.color;if(void 0!==pt.plotY){let bt;$=Math.round(dt.width),tt=(J=Math.floor(dt.x))+$,et=Math.round($/2),G=Math.floor(nt?pt.q1Plot:pt.lowPlot),F=Math.floor(nt?pt.q3Plot:pt.lowPlot),H=Math.floor(pt.highPlot),U=Math.floor(pt.lowPlot),Q||(pt.graphic=Q=rt.g("point").add(this.group),pt.stem=rt.path().addClass("highcharts-boxplot-stem").add(Q),lt&&(pt.whiskers=rt.path().addClass("highcharts-boxplot-whisker").add(Q)),nt&&(pt.box=rt.path(Z).addClass("highcharts-boxplot-box").add(Q)),pt.medianShape=rt.path(V).addClass("highcharts-boxplot-median").add(Q)),at.styledMode||(ut.stroke=pt.stemColor||ot.stemColor||mt,ut["stroke-width"]=_(pt.stemWidth,ot.stemWidth,ot.lineWidth),ut.dashstyle=pt.stemDashStyle||ot.stemDashStyle||ot.dashStyle,pt.stem.attr(ut),lt&&(gt.stroke=pt.whiskerColor||ot.whiskerColor||mt,gt["stroke-width"]=_(pt.whiskerWidth,ot.whiskerWidth,ot.lineWidth),gt.dashstyle=pt.whiskerDashStyle||ot.whiskerDashStyle||ot.dashStyle,pt.whiskers.attr(gt)),nt&&(ct.fill=pt.fillColor||ot.fillColor||mt,ct.stroke=ot.lineColor||mt,ct["stroke-width"]=ot.lineWidth||0,ct.dashstyle=pt.boxDashStyle||ot.boxDashStyle||ot.dashStyle,pt.box.attr(ct)),ft.stroke=pt.medianColor||ot.medianColor||mt,ft["stroke-width"]=_(pt.medianWidth,ot.medianWidth,ot.lineWidth),ft.dashstyle=pt.medianDashStyle||ot.medianDashStyle||ot.dashStyle,pt.medianShape.attr(ft)),bt=[["M",ht=J+et+(K=pt.stem.strokeWidth()%2/2),F],["L",ht,H],["M",ht,G],["L",ht,U]],pt.stem[st]({d:bt}),nt&&(G=Math.floor(G)+(K=pt.box.strokeWidth()%2/2),F=Math.floor(F)+K,J+=K,tt+=K,bt=[["M",J,F],["L",J,G],["L",tt,G],["L",tt,F],["L",J,F],["Z"]],pt.box[st]({d:bt})),lt&&(H+=K=pt.whiskers.strokeWidth()%2/2,U+=K,bt=[["M",ht-(it=/%$/.test(lt)?et*parseFloat(lt)/100:lt/2),H],["L",ht+it,H],["M",ht-it,U],["L",ht+it,U]],pt.whiskers[st]({d:bt})),bt=[["M",J,q=Math.round(pt.medianPlot)+(K=pt.medianShape.strokeWidth()%2/2)],["L",tt,q]],pt.medianShape[st]({d:bt})}}}toYData(G){return[G.low,G.q1,G.median,G.q3,G.high]}}return h.defaultOptions=Z(F.defaultOptions,G),K(h.prototype,{pointArrayMap:["low","q1","median","q3","high"],pointValKey:"high",drawDataLabels:V,setStackedPoints:V}),U.registerSeriesType("boxplot",h),h})),i(H,"Series/Bubble/BubbleLegendDefaults.js",[],(function(){return{borderColor:void 0,borderWidth:2,className:void 0,color:void 0,connectorClassName:void 0,connectorColor:void 0,connectorDistance:60,connectorWidth:1,enabled:!1,labels:{className:void 0,allowOverlap:!1,format:"",formatter:void 0,align:"right",style:{fontSize:"0.9em",color:"#000000"},x:0,y:0},maxSize:60,minSize:10,legendIndex:0,ranges:{value:void 0,borderColor:void 0,color:void 0,connectorColor:void 0},sizeBy:"area",sizeByAbsoluteValue:!1,zIndex:1,zThreshold:0}})),i(H,"Series/Bubble/BubbleLegendItem.js",[H["Core/Color/Color.js"],H["Core/Templating.js"],H["Core/Globals.js"],H["Core/Utilities.js"]],(function(G,F,H,U){let{parse:q}=G,{noop:V}=H,{arrayMax:K,arrayMin:Z,isNumber:_,merge:Q,pick:$,stableSort:J}=U;return class{constructor(G,F){this.setState=V,this.init(G,F)}init(G,F){this.options=G,this.visible=!0,this.chart=F.chart,this.legend=F}addToLegend(G){G.splice(this.options.legendIndex,0,this)}drawLegendSymbol(G){let F;this.chart;let H=$(G.options.itemDistance,20),U=this.legendItem||{},q=this.options,V=q.ranges,K=q.connectorDistance;if(!V||!V.length||!_(V[0].value)){G.options.bubbleLegend.autoRanges=!0;return}J(V,(function(G,F){return F.value-G.value})),this.ranges=V,this.setOptions(),this.render();let Z=this.getMaxLabelSize(),Q=this.ranges[0].radius,tt=2*Q;F=(F=K-Q+Z.width)>0?F:0,this.maxLabel=Z,this.movementX="left"===q.labels.align?F:0,U.labelWidth=tt+F+H,U.labelHeight=tt+Z.height/2}setOptions(){let G=this.ranges,F=this.options,H=this.chart.series[F.seriesIndex],U=this.legend.baseline,V={zIndex:F.zIndex,"stroke-width":F.borderWidth},K={zIndex:F.zIndex,"stroke-width":F.connectorWidth},Z={align:this.legend.options.rtl||"left"===F.labels.align?"right":"left",zIndex:F.zIndex},_=H.options.marker.fillOpacity,J=this.chart.styledMode;G.forEach((function(tt,et){J||(V.stroke=$(tt.borderColor,F.borderColor,H.color),V.fill=$(tt.color,F.color,1!==_?q(H.color).setOpacity(_).get("rgba"):H.color),K.stroke=$(tt.connectorColor,F.connectorColor,H.color)),G[et].radius=this.getRangeRadius(tt.value),G[et]=Q(G[et],{center:G[0].radius-G[et].radius+U}),J||Q(!0,G[et],{bubbleAttribs:Q(V),connectorAttribs:Q(K),labelAttribs:Z})}),this)}getRangeRadius(G){let F=this.options,H=this.options.seriesIndex,U=this.chart.series[H],q=F.ranges[0].value,V=F.ranges[F.ranges.length-1].value,K=F.minSize,Z=F.maxSize;return U.getRadius.call(this,V,q,K,Z,G)}render(){let G=this.legendItem||{},F=this.chart.renderer,H=this.options.zThreshold;for(let U of(this.symbols||(this.symbols={connectors:[],bubbleItems:[],labels:[]}),G.symbol=F.g("bubble-legend"),G.label=F.g("bubble-legend-item").css(this.legend.itemStyle||{}),G.symbol.translateX=0,G.symbol.translateY=0,G.symbol.add(G.label),G.label.add(G.group),this.ranges))U.value>=H&&this.renderRange(U);this.hideOverlappingLabels()}renderRange(G){let F=this.ranges[0],H=this.legend,U=this.options,q=U.labels,V=this.chart,K=V.series[U.seriesIndex],Z=V.renderer,_=this.symbols,Q=_.labels,$=G.center,J=Math.abs(G.radius),tt=U.connectorDistance||0,et=q.align,it=H.options.rtl,st=U.borderWidth,ot=U.connectorWidth,at=F.radius||0,rt=$-J-st/2+ot/2,nt=(rt%1?1:.5)-(ot%2?0:.5),lt=Z.styledMode,ht=it||"left"===et?-tt:tt;"center"===et&&(ht=0,U.connectorDistance=0,G.labelAttribs.align="center"),_.bubbleItems.push(Z.circle(at,$+nt,J).attr(lt?{}:G.bubbleAttribs).addClass((lt?"highcharts-color-"+K.colorIndex+" ":"")+"highcharts-bubble-legend-symbol "+(U.className||"")).add(this.legendItem.symbol)),_.connectors.push(Z.path(Z.crispLine([["M",at,rt],["L",at+ht,rt]],U.connectorWidth)).attr(lt?{}:G.connectorAttribs).addClass((lt?"highcharts-color-"+this.options.seriesIndex+" ":"")+"highcharts-bubble-legend-connectors "+(U.connectorClassName||"")).add(this.legendItem.symbol));let pt=Z.text(this.formatLabel(G)).attr(lt?{}:G.labelAttribs).css(lt?{}:q.style).addClass("highcharts-bubble-legend-labels "+(U.labels.className||"")).add(this.legendItem.symbol),dt={x:at+ht+U.labels.x,y:rt+U.labels.y+.4*pt.getBBox().height};pt.attr(dt),Q.push(pt),pt.placed=!0,pt.alignAttr=dt}getMaxLabelSize(){let G,F;let H=this.symbols.labels;return H.forEach((function(H){F=H.getBBox(!0),G=G?F.width>G.width?F:G:F})),G||{}}formatLabel(G){let H=this.options,U=H.labels.formatter,q=H.labels.format,{numberFormatter:V}=this.chart;return q?F.format(q,G):U?U.call(G):V(G.value,1)}hideOverlappingLabels(){let G=this.chart,F=this.options.labels.allowOverlap,H=this.symbols;!F&&H&&(G.hideOverlappingLabels(H.labels),H.labels.forEach((function(G,F){G.newOpacity?G.newOpacity!==G.oldOpacity&&H.connectors[F].show():H.connectors[F].hide()})))}getRanges(){let G,F,H=this.legend.bubbleLegend,U=H.chart.series,q=H.options.ranges,V=Number.MAX_VALUE,J=-Number.MAX_VALUE;return U.forEach((function(G){G.isBubble&&!G.ignoreSeries&&(F=G.zData.filter(_)).length&&(V=$(G.options.zMin,Math.min(V,Math.max(Z(F),!1===G.options.displayNegative?G.options.zThreshold:-Number.MAX_VALUE))),J=$(G.options.zMax,Math.max(J,K(F))))})),G=V===J?[{value:J}]:[{value:V},{value:(V+J)/2},{value:J,autoRanges:!0}],q.length&&q[0].radius&&G.reverse(),G.forEach((function(F,H){q&&q[H]&&(G[H]=Q(q[H],F))})),G}predictBubbleSizes(){let G,F=this.chart,H=F.legend.options,U=H.floating,q="horizontal"===H.layout,V=q?F.legend.lastLineHeight:0,K=F.plotSizeX,Z=F.plotSizeY,_=F.series[this.options.seriesIndex],Q=_.getPxExtremes(),$=Math.ceil(Q.minPxSize),J=Math.ceil(Q.maxPxSize),tt=_.options.maxSize;return U||!/%$/.test(tt)?G=J:(G=(Math.min(Z,K)+V)*(tt=parseFloat(tt))/100/(tt/100+1),(q&&Z-G>=K||!q&&K-G>=Z)&&(G=J)),[$,Math.ceil(G)]}updateRanges(G,F){let H=this.legend.options.bubbleLegend;H.minSize=G,H.maxSize=F,H.ranges=this.getRanges()}correctSizes(){let G=this.legend,F=this.chart,H=F.series[this.options.seriesIndex],U=H.getPxExtremes(),q=U.maxPxSize,V=this.options.maxSize;Math.abs(Math.ceil(q)-V)>1&&(this.updateRanges(this.options.minSize,U.maxPxSize),G.render())}}})),i(H,"Series/Bubble/BubbleLegendComposition.js",[H["Series/Bubble/BubbleLegendDefaults.js"],H["Series/Bubble/BubbleLegendItem.js"],H["Core/Defaults.js"],H["Core/Globals.js"],H["Core/Utilities.js"]],(function(F,H,U,q,V){let{setOptions:K}=U,{composed:Z}=q,{addEvent:_,objectEach:Q,pushUnique:$,wrap:J}=V;function d(F,H,U){let q,V,K;let Z=(this||G).legend,_=c(this||G)>=0;Z&&Z.options.enabled&&Z.bubbleLegend&&Z.options.bubbleLegend.autoRanges&&_?(q=Z.bubbleLegend.options,V=Z.bubbleLegend.predictBubbleSizes(),Z.bubbleLegend.updateRanges(V[0],V[1]),q.placed||(Z.group.placed=!1,Z.allItems.forEach((G=>{(K=G.legendItem||{}).group&&(K.group.translateY=void 0)}))),Z.render(),this.getMargins(),(this||G).axes.forEach((function(G){G.visible&&G.render(),q.placed||(G.setScale(),G.updateNames(),Q(G.ticks,(function(G){G.isNew=!0,G.isNewLabel=!0})))})),q.placed=!0,this.getMargins(),F.call(this||G,H,U),Z.bubbleLegend.correctSizes(),b(Z,u(Z))):(F.call(this||G,H,U),Z&&Z.options.enabled&&Z.bubbleLegend&&(Z.render(),b(Z,u(Z))))}function c(G){let F=G.series,H=0;for(;H<F.length;){if(F[H]&&F[H].isBubble&&F[H].visible&&F[H].zData.length)return H;H++}return-1}function u(G){let F,H,U,q=G.allItems,V=[],K=q.length,Z=0,_=0;for(Z=0;Z<K;Z++)if(H=q[Z].legendItem||{},U=(q[Z+1]||{}).legendItem||{},H.labelHeight&&(q[Z].itemHeight=H.labelHeight),q[Z]===q[K-1]||H.y!==U.y){for(V.push({height:0}),F=V[V.length-1];_<=Z;_++)q[_].itemHeight>F.height&&(F.height=q[_].itemHeight);F.step=Z}return V}function g(F){let U=(this||G).bubbleLegend,q=(this||G).options,V=q.bubbleLegend,K=c((this||G).chart);U&&U.ranges&&U.ranges.length&&(V.ranges.length&&(V.autoRanges=!!V.ranges[0].autoRanges),this.destroyItem(U)),K>=0&&q.enabled&&V.enabled&&(V.seriesIndex=K,(this||G).bubbleLegend=new H(V,this||G),(this||G).bubbleLegend.addToLegend(F.allItems))}function f(F){let H;if(F.defaultPrevented)return!1;let U=(this||G).chart,q=(this||G).visible,V=(this||G).chart.legend;V&&V.bubbleLegend&&((this||G).visible=!q,(this||G).ignoreSeries=q,H=c(U)>=0,V.bubbleLegend.visible!==H&&(V.update({bubbleLegend:{enabled:H}}),V.bubbleLegend.visible=H),(this||G).visible=q)}function b(G,F){let H,U,q,V,K=G.allItems,Z=G.options.rtl,_=0;K.forEach(((G,K)=>{(V=G.legendItem||{}).group&&(H=V.group.translateX||0,U=V.y||0,((q=G.movementX)||Z&&G.ranges)&&(q=Z?H-G.options.maxSize/2:H+q,V.group.attr({translateX:q})),K>F[_].step&&_++,V.group.attr({translateY:Math.round(U+F[_].height/2)}),V.y=U+F[_].height/2)}))}return{compose:function e(G,H,U){$(Z,e)&&(K({legend:{bubbleLegend:F}}),J(G.prototype,"drawChartBox",d),_(H,"afterGetAllItems",g),_(U,"legendItemClick",f))}}})),i(H,"Series/Bubble/BubblePoint.js",[H["Core/Series/Point.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H){let{seriesTypes:{scatter:{prototype:{pointClass:U}}}}=F,{extend:q}=H;class a extends U{haloPath(F){return G.prototype.haloPath.call(this,0===F?0:(this.marker&&this.marker.radius||0)+F)}}return q(a.prototype,{ttBelow:!1}),a})),i(H,"Series/Bubble/BubbleSeries.js",[H["Series/Bubble/BubbleLegendComposition.js"],H["Series/Bubble/BubblePoint.js"],H["Core/Color/Color.js"],H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(F,H,U,q,V,K){let{parse:Z}=U,{composed:_,noop:Q}=q,{series:$,seriesTypes:{column:{prototype:J},scatter:tt}}=V,{addEvent:et,arrayMax:it,arrayMin:st,clamp:ot,extend:at,isNumber:rt,merge:nt,pick:lt,pushUnique:ht}=K;function S(){let F,H=(this||G).len,{coll:U,isXAxis:q,min:V}=this||G,K=q?"xData":"yData",Z=((this||G).max||0)-(V||0),_=0,Q=H,$=H/Z;("xAxis"===U||"yAxis"===U)&&((this||G).series.forEach((H=>{if(H.bubblePadding&&H.reserveSpace()){(this||G).allowZoomOutside=!0,F=!0;let U=H[K];if(q&&((H.onPoint||H).getRadii(0,0,H),H.onPoint&&(H.radii=H.onPoint.radii)),Z>0){let F=U.length;for(;F--;)if(rt(U[F])&&(this||G).dataMin<=U[F]&&U[F]<=(this||G).max){let G=H.radii&&H.radii[F]||0;_=Math.min((U[F]-V)*$-G,_),Q=Math.max((U[F]-V)*$+G,Q)}}}})),F&&Z>0&&!(this||G).logarithmic&&(Q-=H,$*=(H+Math.max(0,_)-Math.min(Q,H))/H,[["min","userMin",_],["max","userMax",Q]].forEach((F=>{void 0===lt((this||G).options[F[0]],(this||G)[F[1]])&&((this||G)[F[0]]+=F[2]/$)}))))}class M extends tt{static compose(G,H,U,q){F.compose(H,U,q),ht(_,this.compose)&&et(G,"foundExtremes",S)}animate(G){!G&&this.points.length<this.options.animationLimit&&this.points.forEach((function(G){let{graphic:F}=G;F&&F.width&&(this.hasRendered||F.attr({x:G.plotX,y:G.plotY,width:1,height:1}),F.animate(this.markerAttribs(G),this.options.animation))}),this)}getRadii(){let G,F,H,U=this.zData,q=this.yData,V=[],K=this.chart.bubbleZExtremes,{minPxSize:Z,maxPxSize:_}=this.getPxExtremes();if(!K){let G,F=Number.MAX_VALUE,H=-Number.MAX_VALUE;this.chart.series.forEach((U=>{if(U.bubblePadding&&U.reserveSpace()){let q=(U.onPoint||U).getZExtremes();q&&(F=Math.min(lt(F,q.zMin),q.zMin),H=Math.max(lt(H,q.zMax),q.zMax),G=!0)}})),G?(K={zMin:F,zMax:H},this.chart.bubbleZExtremes=K):K={zMin:0,zMax:0}}for(F=0,G=U.length;F<G;F++)H=U[F],V.push(this.getRadius(K.zMin,K.zMax,Z,_,H,q&&q[F]));this.radii=V}getRadius(G,F,H,U,q,V){let K=this.options,Z="width"!==K.sizeBy,_=K.zThreshold,Q=F-G,$=.5;if(null===V||null===q)return null;if(rt(q)){if(K.sizeByAbsoluteValue&&(q=Math.abs(q-_),F=Q=Math.max(F-_,Math.abs(G-_)),G=0),q<G)return H/2-1;Q>0&&($=(q-G)/Q)}return Z&&$>=0&&($=Math.sqrt($)),Math.ceil(H+$*(U-H))/2}hasData(){return!!this.processedXData.length}pointAttribs(G,F){let H=this.options.marker,U=H.fillOpacity,q=$.prototype.pointAttribs.call(this,G,F);return 1!==U&&(q.fill=Z(q.fill).setOpacity(U).get("rgba")),q}translate(){super.translate.call(this),this.getRadii(),this.translateBubble()}translateBubble(){let{data:G,options:F,radii:H}=this,{minPxSize:U}=this.getPxExtremes(),q=G.length;for(;q--;){let V=G[q],K=H?H[q]:0;"z"===this.zoneAxis&&(V.negative=(V.z||0)<(F.zThreshold||0)),rt(K)&&K>=U/2?(V.marker=at(V.marker,{radius:K,width:2*K,height:2*K}),V.dlBox={x:V.plotX-K,y:V.plotY-K,width:2*K,height:2*K}):(V.shapeArgs=V.plotY=V.dlBox=void 0,V.isInside=!1)}}getPxExtremes(){let G=Math.min(this.chart.plotWidth,this.chart.plotHeight),e=F=>{let H;return"string"==typeof F&&(H=/%$/.test(F),F=parseInt(F,10)),H?G*F/100:F},F=e(lt(this.options.minSize,8)),H=Math.max(e(lt(this.options.maxSize,"20%")),F);return{minPxSize:F,maxPxSize:H}}getZExtremes(){let G=this.options,F=(this.zData||[]).filter(rt);if(F.length){let H=lt(G.zMin,ot(st(F),!1===G.displayNegative?G.zThreshold||0:-Number.MAX_VALUE,Number.MAX_VALUE)),U=lt(G.zMax,it(F));if(rt(H)&&rt(U))return{zMin:H,zMax:U}}}}return M.defaultOptions=nt(tt.defaultOptions,{dataLabels:{formatter:function(){let{numberFormatter:F}=(this||G).series.chart,{z:H}=(this||G).point;return rt(H)?F(H,-1):""},inside:!0,verticalAlign:"middle"},animationLimit:250,marker:{lineColor:null,lineWidth:1,fillOpacity:.5,radius:null,states:{hover:{radiusPlus:0}},symbol:"circle"},minSize:8,maxSize:"20%",softThreshold:!1,states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0,zoneAxis:"z"}),at(M.prototype,{alignDataLabel:J.alignDataLabel,applyZones:Q,bubblePadding:!0,isBubble:!0,pointArrayMap:["y","z"],pointClass:H,parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],specialGroup:"group",zoneAxis:"z"}),et(M,"updatedData",(G=>{delete G.target.chart.bubbleZExtremes})),et(M,"remove",(G=>{delete G.target.chart.bubbleZExtremes})),V.registerSeriesType("bubble",M),M})),i(H,"Series/ColumnRange/ColumnRangePoint.js",[H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F){let{seriesTypes:{column:{prototype:{pointClass:{prototype:H}}},arearange:{prototype:{pointClass:U}}}}=G,{extend:q,isNumber:V}=F;class r extends U{isValid(){return V(this.low)}}return q(r.prototype,{setState:H.setState}),r})),i(H,"Series/ColumnRange/ColumnRangeSeries.js",[H["Series/ColumnRange/ColumnRangePoint.js"],H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(F,H,U,q){let{noop:V}=H,{seriesTypes:{arearange:K,column:Z,column:{prototype:_}}}=U,{addEvent:Q,clamp:$,extend:J,isNumber:tt,merge:et,pick:it}=q;class g extends K{setOptions(){return et(!0,arguments[0],{stacking:void 0}),K.prototype.setOptions.apply(this,arguments)}translate(){return _.translate.apply(this)}pointAttribs(){return _.pointAttribs.apply(this,arguments)}translate3dPoints(){return _.translate3dPoints.apply(this,arguments)}translate3dShapes(){return _.translate3dShapes.apply(this,arguments)}afterColumnTranslate(){let G,F,H,U;let q=this.yAxis,V=this.xAxis,K=V.startAngleRad,Z=this.chart,_=this.xAxis.isRadial,Q=Math.max(Z.chartWidth,Z.chartHeight)+999;this.points.forEach((J=>{let st=J.shapeArgs||{},ot=this.options.minPointLength,at=J.plotY,rt=q.translate(J.high,0,1,0,1);if(tt(rt)&&tt(at))if(J.plotHigh=$(rt,-Q,Q),J.plotLow=$(at,-Q,Q),U=J.plotHigh,Math.abs(G=it(J.rectPlotY,J.plotY)-J.plotHigh)<ot?(F=ot-G,G+=F,U-=F/2):G<0&&(G*=-1,U-=G),_&&this.polar)H=J.barX+K,J.shapeType="arc",J.shapeArgs=this.polar.arc(U+G,U,H,H+J.pointWidth);else{st.height=G,st.y=U;let{x:F=0,width:H=0}=st;J.shapeArgs=et(J.shapeArgs,this.crispCol(F,U,H,G)),J.tooltipPos=Z.inverted?[q.len+q.pos-Z.plotLeft-U-G/2,V.len+V.pos-Z.plotTop-F-H/2,G]:[V.left-Z.plotLeft+F+H/2,q.pos-Z.plotTop+U+G/2,G]}}))}}return g.defaultOptions=et(Z.defaultOptions,K.defaultOptions,{borderRadius:{where:"all"},pointRange:null,marker:null,states:{hover:{halo:!1}}}),Q(g,"afterColumnTranslate",(function(){g.prototype.afterColumnTranslate.apply(this||G)}),{order:5}),J(g.prototype,{directTouch:!0,pointClass:F,trackerGroups:["group","dataLabelsGroup"],adjustForMissingColumns:_.adjustForMissingColumns,animate:_.animate,crispCol:_.crispCol,drawGraph:V,drawPoints:_.drawPoints,getSymbol:V,drawTracker:_.drawTracker,getColumnMetrics:_.getColumnMetrics}),U.registerSeriesType("columnrange",g),g})),i(H,"Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js",[],(function(){return{}})),i(H,"Series/ColumnPyramid/ColumnPyramidSeries.js",[H["Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H){let{column:U}=F.seriesTypes,{clamp:q,merge:V,pick:K}=H;class n extends U{translate(){let G=this.chart,F=this.options,H=this.dense=this.closestPointRange*this.xAxis.transA<2,U=this.borderWidth=K(F.borderWidth,H?0:1),V=this.yAxis,Z=F.threshold,_=K(F.minPointLength,5),Q=this.getColumnMetrics(),$=Q.width,J=this.pointXOffset=Q.offset,tt=this.translatedThreshold=V.getThreshold(Z),et=this.barW=Math.max($,1+2*U);for(let H of(G.inverted&&(tt-=.5),F.pointPadding&&(et=Math.ceil(et)),super.translate(),this.points)){let U,it,st,ot,at,rt,nt,lt,ht,pt,dt,ct,ut=K(H.yBottom,tt),gt=999+Math.abs(ut),ft=q(H.plotY,-gt,V.len+gt),mt=et/2,bt=Math.min(ft,ut),yt=Math.max(ft,ut)-bt,xt=H.plotX+J;F.centerInCategory&&(xt=this.adjustForMissingColumns(xt,$,H,Q)),H.barX=xt,H.pointWidth=$,H.tooltipPos=G.inverted?[V.len+V.pos-G.plotLeft-ft,this.xAxis.len-xt-mt,yt]:[xt+mt,ft+V.pos-G.plotTop,yt],U=Z+(H.total||H.y),"percent"===F.stacking&&(U=Z+(H.y<0)?-100:100),st=V.toPixels(U,!0),ot=(it=G.plotHeight-st-(G.plotHeight-tt))?mt*(bt-st)/it:0,at=it?mt*(bt+yt-st)/it:0,nt=xt-ot+mt,lt=xt+ot+mt,ht=xt+at+mt,pt=xt-at+mt,dt=bt-_,ct=bt+yt,H.y<0&&(dt=bt,ct=bt+yt+_),G.inverted&&(rt=V.width-bt,it=st-(V.width-tt),ot=mt*(st-rt)/it,at=mt*(st-(rt-yt))/it,lt=(nt=xt+mt+ot)-2*ot,ht=xt-at+mt,pt=xt+at+mt,dt=bt,ct=bt+yt-_,H.y<0&&(ct=bt+yt+_)),H.shapeType="path",H.shapeArgs={x:nt,y:dt,width:lt-nt,height:yt,d:[["M",nt,dt],["L",lt,dt],["L",ht,ct],["L",pt,ct],["Z"]]}}}}return n.defaultOptions=V(U.defaultOptions,G),F.registerSeriesType("columnpyramid",n),n})),i(H,"Series/ErrorBar/ErrorBarSeriesDefaults.js",[],(function(){return{color:"#000000",grouping:!1,linkedTo:":previous",tooltip:{pointFormat:'<span style="color:{point.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},whiskerWidth:null}})),i(H,"Series/ErrorBar/ErrorBarSeries.js",[H["Series/BoxPlot/BoxPlotSeries.js"],H["Series/Column/ColumnSeries.js"],H["Series/ErrorBar/ErrorBarSeriesDefaults.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(F,H,U,q,V){let{arearange:K}=q.seriesTypes,{addEvent:Z,merge:_,extend:Q}=V;class h extends F{getColumnMetrics(){return this.linkedParent&&this.linkedParent.columnMetrics||H.prototype.getColumnMetrics.call(this)}drawDataLabels(){let G=this.pointValKey;if(K)for(let F of(K.prototype.drawDataLabels.call(this),this.points))F.y=F[G]}toYData(G){return[G.low,G.high]}}return h.defaultOptions=_(F.defaultOptions,U),Z(h,"afterTranslate",(function(){for(let F of(this||G).points)F.plotLow=F.plotY}),{order:0}),Q(h.prototype,{pointArrayMap:["low","high"],pointValKey:"high",doQuartiles:!1}),q.registerSeriesType("errorbar",h),h})),i(H,"Series/Gauge/GaugePoint.js",[H["Core/Series/SeriesRegistry.js"]],(function(G){let{series:{prototype:{pointClass:F}}}=G;return class extends F{setState(G){this.state=G}}})),i(H,"Series/Gauge/GaugeSeries.js",[H["Series/Gauge/GaugePoint.js"],H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H,U){let{noop:q}=F,{series:V,seriesTypes:{column:K}}=H,{clamp:Z,isNumber:_,extend:Q,merge:$,pick:J,pInt:tt,defined:et}=U;class g extends V{translate(){let G=this.yAxis,F=this.options,H=G.center;this.generatePoints(),this.points.forEach((U=>{let q=$(F.dial,U.dial),V=tt(q.radius)*H[2]/200,K=tt(q.baseLength)*V/100,Q=tt(q.rearLength)*V/100,J=q.baseWidth,it=q.topWidth,st=F.overshoot,ot=G.startAngleRad+G.translate(U.y,void 0,void 0,void 0,!0);(_(st)||!1===F.wrap)&&(st=_(st)?st/180*Math.PI:0,ot=Z(ot,G.startAngleRad-st,G.endAngleRad+st)),ot=180*ot/Math.PI,U.shapeType="path";let at=q.path||[["M",-Q,-J/2],["L",K,-J/2],["L",V,-it/2],["L",V,it/2],["L",K,J/2],["L",-Q,J/2],["Z"]];U.shapeArgs={d:at,translateX:H[0],translateY:H[1],rotation:ot},U.plotX=H[0],U.plotY=H[1],et(U.y)&&G.max-G.min&&(U.percentage=(U.y-G.min)/(G.max-G.min)*100)}))}drawPoints(){let G=this,F=G.chart,H=G.yAxis.center,U=G.pivot,q=G.options,V=q.pivot,K=F.renderer;G.points.forEach((H=>{let U=H.graphic,V=H.shapeArgs,Z=V.d,_=$(q.dial,H.dial);U?(U.animate(V),V.d=Z):H.graphic=K[H.shapeType](V).addClass("highcharts-dial").add(G.group),F.styledMode||H.graphic[U?"animate":"attr"]({stroke:_.borderColor,"stroke-width":_.borderWidth,fill:_.backgroundColor})})),U?U.animate({translateX:H[0],translateY:H[1]}):V&&(G.pivot=K.circle(0,0,V.radius).attr({zIndex:2}).addClass("highcharts-pivot").translate(H[0],H[1]).add(G.group),F.styledMode||G.pivot.attr({fill:V.backgroundColor,stroke:V.borderColor,"stroke-width":V.borderWidth}))}animate(G){let F=this;G||F.points.forEach((G=>{let H=G.graphic;H&&(H.attr({rotation:180*F.yAxis.startAngleRad/Math.PI}),H.animate({rotation:G.shapeArgs.rotation},F.options.animation))}))}render(){this.group=this.plotGroup("group","series",this.visible?"inherit":"hidden",this.options.zIndex,this.chart.seriesGroup),V.prototype.render.call(this),this.group.clip(this.chart.clipRect)}setData(G,F){V.prototype.setData.call(this,G,!1),this.processData(),this.generatePoints(),J(F,!0)&&this.chart.redraw()}hasData(){return!!this.points.length}}return g.defaultOptions=$(V.defaultOptions,{dataLabels:{borderColor:"#cccccc",borderRadius:3,borderWidth:1,crop:!1,defer:!1,enabled:!0,verticalAlign:"top",y:15,zIndex:2},dial:{backgroundColor:"#000000",baseLength:"70%",baseWidth:3,borderColor:"#cccccc",borderWidth:0,radius:"80%",rearLength:"10%",topWidth:1},pivot:{radius:5,borderWidth:0,borderColor:"#cccccc",backgroundColor:"#000000"},tooltip:{headerFormat:""},showInLegend:!1}),Q(g.prototype,{angular:!0,directTouch:!0,drawGraph:q,drawTracker:K.prototype.drawTracker,fixedBox:!0,forceDL:!0,noSharedTooltip:!0,pointClass:G,trackerGroups:["group","dataLabelsGroup"]}),H.registerSeriesType("gauge",g),g})),i(H,"Series/DragNodesComposition.js",[H["Core/Globals.js"],H["Core/Utilities.js"]],(function(F,H){let{composed:U}=F,{addEvent:q,pushUnique:V}=H;function a(){let F,H,U;let V=this||G;V.container&&(F=q(V.container,"mousedown",(G=>{let F=V.hoverPoint;F&&F.series&&F.series.hasDraggableNodes&&F.series.options.draggable&&(F.series.onMouseDown(F,G),H=q(V.container,"mousemove",(G=>F&&F.series&&F.series.onMouseMove(F,G))),U=q(V.container.ownerDocument,"mouseup",(G=>(H(),U(),F&&F.series&&F.series.onMouseUp(F,G)))))}))),q(V,"destroy",(function(){F()}))}return{compose:function t(G){V(U,t)&&q(G,"load",a)},onMouseDown:function(F,H){let U=(this||G).chart.pointer.normalize(H);F.fixedPosition={chartX:U.chartX,chartY:U.chartY,plotX:F.plotX,plotY:F.plotY},F.inDragMode=!0},onMouseMove:function(F,H){if(F.fixedPosition&&F.inDragMode){let U,q;let V=(this||G).chart,K=V.pointer.normalize(H),Z=F.fixedPosition.chartX-K.chartX,_=F.fixedPosition.chartY-K.chartY,Q=V.graphLayoutsLookup;(Math.abs(Z)>5||Math.abs(_)>5)&&(U=F.fixedPosition.plotX-Z,q=F.fixedPosition.plotY-_,V.isInsidePlot(U,q)&&(F.plotX=U,F.plotY=q,F.hasDragged=!0,this.redrawHalo(F),Q.forEach((G=>{G.restartSimulation()}))))}},onMouseUp:function(F,H){F.fixedPosition&&(F.hasDragged&&((this||G).layout.enableSimulation?(this||G).layout.start():(this||G).chart.redraw()),F.inDragMode=F.hasDragged=!1,(this||G).options.fixedDraggable||delete F.fixedPosition)},redrawHalo:function(F){F&&(this||G).halo&&(this||G).halo.attr({d:F.haloPath((this||G).options.states.hover.halo.size)})}}})),i(H,"Series/GraphLayoutComposition.js",[H["Core/Animation/AnimationUtilities.js"],H["Core/Globals.js"],H["Core/Utilities.js"]],(function(F,H,U){let{setAnimation:q}=F,{composed:V}=H,{addEvent:K,pushUnique:Z}=U;function n(){(this||G).graphLayoutsLookup&&((this||G).graphLayoutsLookup.forEach((G=>{G.updateSimulation()})),this.redraw())}function l(){(this||G).graphLayoutsLookup&&((this||G).graphLayoutsLookup.forEach((G=>{G.updateSimulation(!1)})),this.redraw())}function h(){(this||G).graphLayoutsLookup&&(this||G).graphLayoutsLookup.forEach((G=>{G.stop()}))}function p(){let F,H=!1,i=G=>{G.maxIterations--&&isFinite(G.temperature)&&!G.isStable()&&!G.enableSimulation&&(G.beforeStep&&G.beforeStep(),G.step(),F=!1,H=!0)};if((this||G).graphLayoutsLookup){for(q(!1,this||G),(this||G).graphLayoutsLookup.forEach((G=>G.start()));!F;)F=!0,(this||G).graphLayoutsLookup.forEach(i);H&&(this||G).series.forEach((G=>{G&&G.layout&&G.render()}))}}return{compose:function t(G){Z(V,t)&&(K(G,"afterPrint",n),K(G,"beforePrint",l),K(G,"predraw",h),K(G,"render",p))},integrations:{},layouts:{}}})),i(H,"Series/PackedBubble/PackedBubblePoint.js",[H["Core/Chart/Chart.js"],H["Core/Series/Point.js"],H["Core/Series/SeriesRegistry.js"]],(function(G,F,H){let{seriesTypes:{bubble:{prototype:{pointClass:U}}}}=H;return class extends U{destroy(){return this.series.layout&&this.series.layout.removeElementFromCollection(this,this.series.layout.nodes),F.prototype.destroy.apply(this,arguments)}firePointEvent(){let G=this.series,H=G.options;if(this.isParentNode&&H.parentNode){let G=H.allowPointSelect;H.allowPointSelect=H.parentNode.allowPointSelect,F.prototype.firePointEvent.apply(this,arguments),H.allowPointSelect=G}else F.prototype.firePointEvent.apply(this,arguments)}select(){let H=this.series,U=H.chart;this.isParentNode?(U.getSelectedPoints=U.getSelectedParentNodes,F.prototype.select.apply(this,arguments),U.getSelectedPoints=G.prototype.getSelectedPoints):F.prototype.select.apply(this,arguments)}}})),i(H,"Series/PackedBubble/PackedBubbleSeriesDefaults.js",[H["Core/Utilities.js"]],(function(F){let{isNumber:H}=F;return{minSize:"10%",maxSize:"50%",sizeBy:"area",zoneAxis:"y",crisp:!1,tooltip:{pointFormat:"Value: {point.value}"},draggable:!0,useSimulation:!0,parentNode:{allowPointSelect:!1},dataLabels:{formatter:function(){let{numberFormatter:F}=(this||G).series.chart,{value:U}=(this||G).point;return H(U)?F(U,-1):""},parentNodeFormatter:function(){return(this||G).name},parentNodeTextPath:{enabled:!0},padding:0,style:{transition:"opacity 2000ms"}},layoutAlgorithm:{initialPositions:"circle",initialPositionRadius:20,bubblePadding:5,parentNodeLimit:!1,seriesInteraction:!0,dragBetweenSeries:!1,parentNodeOptions:{maxIterations:400,gravitationalConstant:.03,maxSpeed:50,initialPositionRadius:100,seriesInteraction:!0,marker:{fillColor:null,fillOpacity:1,lineWidth:null,lineColor:null,symbol:"circle"}},enableSimulation:!0,type:"packedbubble",integration:"packedbubble",maxIterations:1e3,splitSeries:!1,maxSpeed:5,gravitationalConstant:.01,friction:-.981}}})),i(H,"Series/Networkgraph/VerletIntegration.js",[],(function(){return{attractive:function(F,H,U){let q=F.getMass(),V=-U.x*H*(this||G).diffTemperature,K=-U.y*H*(this||G).diffTemperature;F.fromNode.fixedPosition||(F.fromNode.plotX-=V*q.fromNode/F.fromNode.degree,F.fromNode.plotY-=K*q.fromNode/F.fromNode.degree),F.toNode.fixedPosition||(F.toNode.plotX+=V*q.toNode/F.toNode.degree,F.toNode.plotY+=K*q.toNode/F.toNode.degree)},attractiveForceFunction:function(G,F){return(F-G)/G},barycenter:function(){let F=(this||G).options.gravitationalConstant,H=(this||G).barycenter.xFactor,U=(this||G).barycenter.yFactor;H=(H-((this||G).box.left+(this||G).box.width)/2)*F,U=(U-((this||G).box.top+(this||G).box.height)/2)*F,(this||G).nodes.forEach((function(G){G.fixedPosition||(G.plotX-=H/G.mass/G.degree,G.plotY-=U/G.mass/G.degree)}))},getK:function(G){return Math.pow(G.box.width*G.box.height/G.nodes.length,.5)},integrate:function(G,F){let H=-G.options.friction,U=G.options.maxSpeed,q=F.prevX,V=F.prevY,K=(F.plotX+F.dispX-q)*H,Z=(F.plotY+F.dispY-V)*H,_=Math.abs,Q=_(K)/(K||1),$=_(Z)/(Z||1);K=Q*Math.min(U,Math.abs(K)),Z=$*Math.min(U,Math.abs(Z)),F.prevX=F.plotX+F.dispX,F.prevY=F.plotY+F.dispY,F.plotX+=K,F.plotY+=Z,F.temperature=G.vectorLength({x:K,y:Z})},repulsive:function(F,H,U){let q=H*(this||G).diffTemperature/F.mass/F.degree;F.fixedPosition||(F.plotX+=U.x*q,F.plotY+=U.y*q)},repulsiveForceFunction:function(G,F){return(F-G)/G*(F>G?1:0)}}})),i(H,"Series/PackedBubble/PackedBubbleIntegration.js",[H["Core/Globals.js"],H["Series/Networkgraph/VerletIntegration.js"]],(function(F,H){let{noop:U}=F,q={barycenter:function(){let F,H;let U=(this||G).options.gravitationalConstant,q=(this||G).box,V=(this||G).nodes;for(let K of V)(this||G).options.splitSeries&&!K.isParentNode?(F=K.series.parentNode.plotX,H=K.series.parentNode.plotY):(F=q.width/2,H=q.height/2),K.fixedPosition||(K.plotX-=(K.plotX-F)*U/(K.mass*Math.sqrt(V.length)),K.plotY-=(K.plotY-H)*U/(K.mass*Math.sqrt(V.length)))},getK:U,integrate:H.integrate,repulsive:function(F,H,U,q){let V=H*(this||G).diffTemperature/F.mass/F.degree,K=U.x*V,Z=U.y*V;F.fixedPosition||(F.plotX+=K,F.plotY+=Z),q.fixedPosition||(q.plotX-=K,q.plotY-=Z)},repulsiveForceFunction:function(G,F,H,U){return Math.min(G,(H.marker.radius+U.marker.radius)/2)}};return q})),i(H,"Series/Networkgraph/EulerIntegration.js",[],(function(){return{attractive:function(G,F,H,U){let q=G.getMass(),V=H.x/U*F,K=H.y/U*F;G.fromNode.fixedPosition||(G.fromNode.dispX-=V*q.fromNode/G.fromNode.degree,G.fromNode.dispY-=K*q.fromNode/G.fromNode.degree),G.toNode.fixedPosition||(G.toNode.dispX+=V*q.toNode/G.toNode.degree,G.toNode.dispY+=K*q.toNode/G.toNode.degree)},attractiveForceFunction:function(G,F){return G*G/F},barycenter:function(){let F=(this||G).options.gravitationalConstant,H=(this||G).barycenter.xFactor,U=(this||G).barycenter.yFactor;(this||G).nodes.forEach((function(G){if(!G.fixedPosition){let q=G.getDegree(),V=q*(1+q/2);G.dispX+=(H-G.plotX)*F*V/G.degree,G.dispY+=(U-G.plotY)*F*V/G.degree}}))},getK:function(G){return Math.pow(G.box.width*G.box.height/G.nodes.length,.3)},integrate:function(G,F){let H;F.dispX+=F.dispX*G.options.friction,F.dispY+=F.dispY*G.options.friction,0!==(H=F.temperature=G.vectorLength({x:F.dispX,y:F.dispY}))&&(F.plotX+=F.dispX/H*Math.min(Math.abs(F.dispX),G.temperature),F.plotY+=F.dispY/H*Math.min(Math.abs(F.dispY),G.temperature))},repulsive:function(G,F,H,U){G.dispX+=H.x/U*F/G.degree,G.dispY+=H.y/U*F/G.degree},repulsiveForceFunction:function(G,F){return F*F/G}}})),i(H,"Series/Networkgraph/QuadTreeNode.js",[],(function(){class t{constructor(G){this.body=!1,this.isEmpty=!1,this.isInternal=!1,this.nodes=[],this.box=G,this.boxSize=Math.min(G.width,G.height)}divideBox(){let G=this.box.width/2,F=this.box.height/2;this.nodes[0]=new t({left:this.box.left,top:this.box.top,width:G,height:F}),this.nodes[1]=new t({left:this.box.left+G,top:this.box.top,width:G,height:F}),this.nodes[2]=new t({left:this.box.left+G,top:this.box.top+F,width:G,height:F}),this.nodes[3]=new t({left:this.box.left,top:this.box.top+F,width:G,height:F})}getBoxPosition(G){let F=G.plotX<this.box.left+this.box.width/2,H=G.plotY<this.box.top+this.box.height/2;return F?H?0:3:H?1:2}insert(G,F){let H;this.isInternal?this.nodes[this.getBoxPosition(G)].insert(G,F-1):(this.isEmpty=!1,this.body?F?(this.isInternal=!0,this.divideBox(),!0!==this.body&&(this.nodes[this.getBoxPosition(this.body)].insert(this.body,F-1),this.body=!0),this.nodes[this.getBoxPosition(G)].insert(G,F-1)):((H=new t({top:G.plotX||NaN,left:G.plotY||NaN,width:.1,height:.1})).body=G,H.isInternal=!1,this.nodes.push(H)):(this.isInternal=!1,this.body=G))}updateMassAndCenter(){let G=0,F=0,H=0;if(this.isInternal){for(let U of this.nodes)U.isEmpty||(G+=U.mass,F+=U.plotX*U.mass,H+=U.plotY*U.mass);F/=G,H/=G}else this.body&&(G=this.body.mass,F=this.body.plotX,H=this.body.plotY);this.mass=G,this.plotX=F,this.plotY=H}}return t})),i(H,"Series/Networkgraph/QuadTree.js",[H["Series/Networkgraph/QuadTreeNode.js"]],(function(G){return class{constructor(F,H,U,q){this.box={left:F,top:H,width:U,height:q},this.maxDepth=25,this.root=new G(this.box),this.root.isInternal=!0,this.root.isRoot=!0,this.root.divideBox()}calculateMassAndCenter(){this.visitNodeRecursive(null,null,(function(G){G.updateMassAndCenter()}))}insertNodes(G){for(let F of G)this.root.insert(F,this.maxDepth)}visitNodeRecursive(G,F,H){let U;if(G||(G=this.root),G===this.root&&F&&(U=F(G)),!1!==U){for(let q of G.nodes){if(q.isInternal){if(F&&(U=F(q)),!1===U)continue;this.visitNodeRecursive(q,F,H)}else q.body&&F&&F(q.body);H&&H(q)}G===this.root&&H&&H(G)}}}})),i(H,"Series/Networkgraph/ReingoldFruchtermanLayout.js",[H["Series/Networkgraph/EulerIntegration.js"],H["Core/Globals.js"],H["Series/GraphLayoutComposition.js"],H["Series/Networkgraph/QuadTree.js"],H["Core/Utilities.js"],H["Series/Networkgraph/VerletIntegration.js"]],(function(G,F,H,U,q,V){let{win:K}=F,{clamp:Z,defined:_,isFunction:Q,fireEvent:$,pick:J}=q;class c{constructor(){this.box={},this.currentStep=0,this.initialRendering=!0,this.links=[],this.nodes=[],this.series=[],this.simulation=!1}static compose(F){H.compose(F),H.integrations.euler=G,H.integrations.verlet=V,H.layouts["reingold-fruchterman"]=c}init(G){this.options=G,this.nodes=[],this.links=[],this.series=[],this.box={x:0,y:0,width:0,height:0},this.setInitialRendering(!0),this.integration=H.integrations[G.integration],this.enableSimulation=G.enableSimulation,this.attractiveForce=J(G.attractiveForce,this.integration.attractiveForceFunction),this.repulsiveForce=J(G.repulsiveForce,this.integration.repulsiveForceFunction),this.approximation=G.approximation}updateSimulation(G){this.enableSimulation=J(G,this.options.enableSimulation)}start(){let G=this.series,F=this.options;this.currentStep=0,this.forces=G[0]&&G[0].forces||[],this.chart=G[0]&&G[0].chart,this.initialRendering&&(this.initPositions(),G.forEach((function(G){G.finishedAnimating=!0,G.render()}))),this.setK(),this.resetSimulation(F),this.enableSimulation&&this.step()}step(){let G=this.series;for(let G of(this.currentStep++,"barnes-hut"===this.approximation&&(this.createQuadTree(),this.quadTree.calculateMassAndCenter()),this.forces||[]))this[G+"Forces"](this.temperature);if(this.applyLimits(),this.temperature=this.coolDown(this.startTemperature,this.diffTemperature,this.currentStep),this.prevSystemTemperature=this.systemTemperature,this.systemTemperature=this.getSystemTemperature(),this.enableSimulation){for(let F of G)F.chart&&F.render();this.maxIterations--&&isFinite(this.temperature)&&!this.isStable()?(this.simulation&&K.cancelAnimationFrame(this.simulation),this.simulation=K.requestAnimationFrame((()=>this.step()))):(this.simulation=!1,this.series.forEach((G=>{$(G,"afterSimulation")})))}}stop(){this.simulation&&K.cancelAnimationFrame(this.simulation)}setArea(G,F,H,U){this.box={left:G,top:F,width:H,height:U}}setK(){this.k=this.options.linkLength||this.integration.getK(this)}addElementsToCollection(G,F){for(let H of G)-1===F.indexOf(H)&&F.push(H)}removeElementFromCollection(G,F){let H=F.indexOf(G);-1!==H&&F.splice(H,1)}clear(){this.nodes.length=0,this.links.length=0,this.series.length=0,this.resetSimulation()}resetSimulation(){this.forcedStop=!1,this.systemTemperature=0,this.setMaxIterations(),this.setTemperature(),this.setDiffTemperature()}restartSimulation(){this.simulation?this.resetSimulation():(this.setInitialRendering(!1),this.enableSimulation?this.start():this.setMaxIterations(1),this.chart&&this.chart.redraw(),this.setInitialRendering(!0))}setMaxIterations(G){this.maxIterations=J(G,this.options.maxIterations)}setTemperature(){this.temperature=this.startTemperature=Math.sqrt(this.nodes.length)}setDiffTemperature(){this.diffTemperature=this.startTemperature/(this.options.maxIterations+1)}setInitialRendering(G){this.initialRendering=G}createQuadTree(){this.quadTree=new U(this.box.left,this.box.top,this.box.width,this.box.height),this.quadTree.insertNodes(this.nodes)}initPositions(){let G=this.options.initialPositions;if(Q(G))for(let F of(G.call(this),this.nodes))_(F.prevX)||(F.prevX=F.plotX),_(F.prevY)||(F.prevY=F.plotY),F.dispX=0,F.dispY=0;else"circle"===G?this.setCircularPositions():this.setRandomPositions()}setCircularPositions(){let G;let F=this.box,H=this.nodes,U=H.length+1,q=2*Math.PI/U,V=H.filter((function(G){return 0===G.linksTo.length})),K={},Z=this.options.initialPositionRadius,l=G=>{for(let F of G.linksFrom||[])K[F.toNode.id]||(K[F.toNode.id]=!0,_.push(F.toNode),l(F.toNode))},_=[];for(let G of V)_.push(G),l(G);if(_.length)for(let G of H)-1===_.indexOf(G)&&_.push(G);else _=H;for(let H=0,U=_.length;H<U;++H)(G=_[H]).plotX=G.prevX=J(G.plotX,F.width/2+Z*Math.cos(H*q)),G.plotY=G.prevY=J(G.plotY,F.height/2+Z*Math.sin(H*q)),G.dispX=0,G.dispY=0}setRandomPositions(){let G;let F=this.box,H=this.nodes,U=H.length+1,o=G=>{let F=G*G/Math.PI;return F-Math.floor(F)};for(let q=0,V=H.length;q<V;++q)(G=H[q]).plotX=G.prevX=J(G.plotX,F.width*o(q)),G.plotY=G.prevY=J(G.plotY,F.height*o(U+q)),G.dispX=0,G.dispY=0}force(G,...F){this.integration[G].apply(this,F)}barycenterForces(){this.getBarycenter(),this.force("barycenter")}getBarycenter(){let G=0,F=0,H=0;for(let U of this.nodes)F+=U.plotX*U.mass,H+=U.plotY*U.mass,G+=U.mass;return this.barycenter={x:F,y:H,xFactor:F/G,yFactor:H/G},this.barycenter}barnesHutApproximation(G,F){let H,U;let q=this.getDistXY(G,F),V=this.vectorLength(q);return G!==F&&0!==V&&(F.isInternal?F.boxSize/V<this.options.theta&&0!==V?(U=this.repulsiveForce(V,this.k),this.force("repulsive",G,U*F.mass,q,V),H=!1):H=!0:(U=this.repulsiveForce(V,this.k),this.force("repulsive",G,U*F.mass,q,V))),H}repulsiveForces(){if("barnes-hut"===this.approximation)for(let G of this.nodes)this.quadTree.visitNodeRecursive(null,(F=>this.barnesHutApproximation(G,F)));else{let G,F,H;for(let U of this.nodes)for(let q of this.nodes)U===q||U.fixedPosition||(H=this.getDistXY(U,q),0!==(F=this.vectorLength(H))&&(G=this.repulsiveForce(F,this.k),this.force("repulsive",U,G*q.mass,H,F)))}}attractiveForces(){let G,F,H;for(let U of this.links)U.fromNode&&U.toNode&&(G=this.getDistXY(U.fromNode,U.toNode),0!==(F=this.vectorLength(G))&&(H=this.attractiveForce(F,this.k),this.force("attractive",U,H,G,F)))}applyLimits(){let G=this.nodes;for(let F of G){if(F.fixedPosition)return;this.integration.integrate(this,F),this.applyLimitBox(F,this.box),F.dispX=0,F.dispY=0}}applyLimitBox(G,F){let H=G.radius;G.plotX=Z(G.plotX,F.left+H,F.width-H),G.plotY=Z(G.plotY,F.top+H,F.height-H)}coolDown(G,F,H){return G-F*H}isStable(){return 1e-5>Math.abs(this.systemTemperature-this.prevSystemTemperature)||this.temperature<=0}getSystemTemperature(){let G=0;for(let F of this.nodes)G+=F.temperature;return G}vectorLength(G){return Math.sqrt(G.x*G.x+G.y*G.y)}getDistR(G,F){let H=this.getDistXY(G,F);return this.vectorLength(H)}getDistXY(G,F){let H=G.plotX-F.plotX,U=G.plotY-F.plotY;return{x:H,y:U,absX:Math.abs(H),absY:Math.abs(U)}}}return c})),i(H,"Series/PackedBubble/PackedBubbleLayout.js",[H["Series/GraphLayoutComposition.js"],H["Core/Globals.js"],H["Series/PackedBubble/PackedBubbleIntegration.js"],H["Series/Networkgraph/ReingoldFruchtermanLayout.js"],H["Core/Utilities.js"]],(function(F,H,U,q,V){let{composed:K}=H,{addEvent:Z,pick:_,pushUnique:Q}=V;function h(){let F=(this||G).series,H=[];return F.forEach((G=>{G.parentNode&&G.parentNode.selected&&H.push(G.parentNode)})),H}function p(){(this||G).allDataPoints&&delete(this||G).allDataPoints}class d extends q{constructor(){super(...arguments),this.index=NaN,this.nodes=[],this.series=[]}static compose(G){if(q.compose(G),F.integrations.packedbubble=U,F.layouts.packedbubble=d,Q(K,this.compose)){Z(G,"beforeRedraw",p);let F=G.prototype;F.getSelectedParentNodes=h}}beforeStep(){this.options.marker&&this.series.forEach((G=>{G&&G.calculateParentRadius()}))}isStable(){let G=Math.abs(this.prevSystemTemperature-this.systemTemperature),F=10*this.systemTemperature/Math.sqrt(this.nodes.length);return 1>Math.abs(F)&&G<1e-5||this.temperature<=0}setCircularPositions(){let G,F,H=this.box,U=this.nodes,q=U.length+1,V=2*Math.PI/q,K=this.options.initialPositionRadius,Z=0;for(let q of U)this.options.splitSeries&&!q.isParentNode?(G=q.series.parentNode.plotX,F=q.series.parentNode.plotY):(G=H.width/2,F=H.height/2),q.plotX=q.prevX=_(q.plotX,G+K*Math.cos(q.index||Z*V)),q.plotY=q.prevY=_(q.plotY,F+K*Math.sin(q.index||Z*V)),q.dispX=0,q.dispY=0,Z++}repulsiveForces(){let G,F,H;let U=this,q=U.options.bubblePadding;U.nodes.forEach((V=>{V.degree=V.mass,V.neighbours=0,U.nodes.forEach((K=>{G=0,V!==K&&!V.fixedPosition&&(U.options.seriesInteraction||V.series===K.series)&&(H=U.getDistXY(V,K),(F=U.vectorLength(H)-(V.marker.radius+K.marker.radius+q))<0&&(V.degree+=.01,V.neighbours++,G=U.repulsiveForce(-F/Math.sqrt(V.neighbours),U.k,V,K)),U.force("repulsive",V,G*K.mass,H,K,F))}))}))}applyLimitBox(G,F){let H,U;this.options.splitSeries&&!G.isParentNode&&this.options.parentNodeLimit&&(H=this.getDistXY(G,G.series.parentNode),(U=G.series.parentNodeRadius-G.marker.radius-this.vectorLength(H))<0&&U>-2*G.marker.radius&&(G.plotX-=.01*H.x,G.plotY-=.01*H.y)),super.applyLimitBox(G,F)}}return F.layouts.packedbubble=d,d})),i(H,"Series/SimulationSeriesUtilities.js",[H["Core/Utilities.js"],H["Core/Animation/AnimationUtilities.js"]],(function(F,H){let{merge:U,syncTimeout:q}=F,{animObject:V}=H;return{initDataLabels:function(){let F=(this||G).options.dataLabels;if(!(this||G).dataLabelsGroup){let H=this.initDataLabelsGroup();return!(this||G).chart.styledMode&&F?.style&&H.css(F.style),H.attr({opacity:0}),(this||G).visible&&H.show(),H}return(this||G).dataLabelsGroup.attr(U({opacity:1},this.getPlotBox("data-labels"))),(this||G).dataLabelsGroup},initDataLabelsDefer:function(){let F=(this||G).options.dataLabels;F?.defer&&(this||G).options.layoutAlgorithm?.enableSimulation?q((()=>{(this||G).deferDataLabels=!1}),F?V(F.animation).defer:0):(this||G).deferDataLabels=!1}}})),i(H,"Series/PackedBubble/PackedBubbleSeries.js",[H["Core/Color/Color.js"],H["Series/DragNodesComposition.js"],H["Series/GraphLayoutComposition.js"],H["Core/Globals.js"],H["Series/PackedBubble/PackedBubblePoint.js"],H["Series/PackedBubble/PackedBubbleSeriesDefaults.js"],H["Series/PackedBubble/PackedBubbleLayout.js"],H["Core/Series/SeriesRegistry.js"],H["Series/SimulationSeriesUtilities.js"],H["Core/Utilities.js"]],(function(G,F,H,U,q,V,K,Z,_,Q){let{parse:$}=G,{noop:J}=U,{series:{prototype:tt},seriesTypes:{bubble:et}}=Z,{initDataLabels:it,initDataLabelsDefer:st}=_,{addEvent:ot,clamp:at,defined:rt,extend:nt,fireEvent:lt,isArray:ht,isNumber:pt,merge:dt,pick:ct}=Q;class v extends et{constructor(){super(...arguments),this.parentNodeMass=0,this.deferDataLabels=!0}static compose(G,H,U,q){et.compose(G,H,U,q),F.compose(H),K.compose(H)}accumulateAllPoints(){let G;let F=this.chart,H=[];for(let U of F.series)if(U.is("packedbubble")&&U.reserveSpace()){G=U.yData||[];for(let F=0;F<G.length;F++)H.push([null,null,G[F],U.index,F,{id:F,marker:{radius:0}}])}return H}addLayout(){let G,F=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},U=F.type||"packedbubble",q=this.chart.options.chart,V=this.chart.graphLayoutsStorage,K=this.chart.graphLayoutsLookup;V||(this.chart.graphLayoutsStorage=V={},this.chart.graphLayoutsLookup=K=[]),(G=V[U])||(F.enableSimulation=rt(q.forExport)?!q.forExport:F.enableSimulation,V[U]=G=new H.layouts[U],G.init(F),K.splice(G.index,0,G)),this.layout=G,this.points.forEach((G=>{G.mass=2,G.degree=1,G.collisionNmb=1})),G.setArea(0,0,this.chart.plotWidth,this.chart.plotHeight),G.addElementsToCollection([this],G.series),G.addElementsToCollection(this.points,G.nodes)}addSeriesLayout(){let G=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},F=G.type||"packedbubble",U=this.chart.graphLayoutsStorage,q=this.chart.graphLayoutsLookup,V=dt(G,G.parentNodeOptions,{enableSimulation:this.layout.options.enableSimulation}),K=U[F+"-series"];K||(U[F+"-series"]=K=new H.layouts[F],K.init(V),q.splice(K.index,0,K)),this.parentNodeLayout=K,this.createParentNodes()}calculateParentRadius(){let G=this.seriesBox();this.parentNodeRadius=at(Math.sqrt(2*this.parentNodeMass/Math.PI)+20,20,G?Math.max(Math.sqrt(Math.pow(G.width,2)+Math.pow(G.height,2))/2+20,20):Math.sqrt(2*this.parentNodeMass/Math.PI)+20),this.parentNode&&(this.parentNode.marker.radius=this.parentNode.radius=this.parentNodeRadius)}calculateZExtremes(){let G=this.chart,F=G.series,H=this.options.zMin,U=this.options.zMax,q=1/0,V=-1/0;return H&&U?[H,U]:(F.forEach((G=>{G.yData.forEach((G=>{rt(G)&&(G>V&&(V=G),G<q&&(q=G))}))})),[H=ct(H,q),U=ct(U,V)])}checkOverlap(G,F){let H=G[0]-F[0],U=G[1]-F[1],q=G[2]+F[2];return Math.sqrt(H*H+U*U)-Math.abs(q)<-.001}createParentNodes(){let G,F=this.pointClass,H=this.chart,U=this.parentNodeLayout,q=this.layout.options,V=this.parentNode,K={radius:this.parentNodeRadius,lineColor:this.color,fillColor:$(this.color).brighten(.4).get()};q.parentNodeOptions&&(K=dt(q.parentNodeOptions.marker||{},K)),this.parentNodeMass=0,this.points.forEach((G=>{this.parentNodeMass+=Math.PI*Math.pow(G.marker.radius,2)})),this.calculateParentRadius(),U.nodes.forEach((F=>{F.seriesIndex===this.index&&(G=!0)})),U.setArea(0,0,H.plotWidth,H.plotHeight),G||(V||(V=new F(this,{mass:this.parentNodeRadius/2,marker:K,dataLabels:{inside:!1},states:{normal:{marker:K},hover:{marker:K}},dataLabelOnNull:!0,degree:this.parentNodeRadius,isParentNode:!0,seriesIndex:this.index})),this.parentNode&&(V.plotX=this.parentNode.plotX,V.plotY=this.parentNode.plotY),this.parentNode=V,U.addElementsToCollection([this],U.series),U.addElementsToCollection([V],U.nodes))}deferLayout(){let G=this.options.layoutAlgorithm;this.visible&&(this.addLayout(),G.splitSeries&&this.addSeriesLayout())}destroy(){this.chart.graphLayoutsLookup&&this.chart.graphLayoutsLookup.forEach((G=>{G.removeElementFromCollection(this,G.series)}),this),this.parentNode&&this.parentNodeLayout&&(this.parentNodeLayout.removeElementFromCollection(this.parentNode,this.parentNodeLayout.nodes),this.parentNode.dataLabel&&(this.parentNode.dataLabel=this.parentNode.dataLabel.destroy())),tt.destroy.apply(this,arguments)}drawDataLabels(){!this.deferDataLabels&&(tt.drawDataLabels.call(this,this.points),this.parentNode&&(this.parentNode.formatPrefix="parentNode",tt.drawDataLabels.call(this,[this.parentNode])))}drawGraph(){if(!this.layout||!this.layout.options.splitSeries)return;let G=this.chart,F=this.layout.options.parentNodeOptions.marker,H={fill:F.fillColor||$(this.color).brighten(.4).get(),opacity:F.fillOpacity,stroke:F.lineColor||this.color,"stroke-width":ct(F.lineWidth,this.options.lineWidth)},U={};this.parentNodesGroup=this.plotGroup("parentNodesGroup","parentNode",this.visible?"inherit":"hidden",.1,G.seriesGroup),this.group?.attr({zIndex:2}),this.calculateParentRadius(),this.parentNode&&rt(this.parentNode.plotX)&&rt(this.parentNode.plotY)&&rt(this.parentNodeRadius)&&(U=dt({x:this.parentNode.plotX-this.parentNodeRadius,y:this.parentNode.plotY-this.parentNodeRadius,width:2*this.parentNodeRadius,height:2*this.parentNodeRadius},H),this.parentNode.graphic||(this.graph=this.parentNode.graphic=G.renderer.symbol(H.symbol).add(this.parentNodesGroup)),this.parentNode.graphic.attr(U))}drawTracker(){let G;let F=this.parentNode;super.drawTracker(),F&&(G=ht(F.dataLabels)?F.dataLabels:F.dataLabel?[F.dataLabel]:[],F.graphic&&(F.graphic.element.point=F),G.forEach((G=>{G.div?G.div.point=F:G.element.point=F})))}getPointRadius(){let G,F,H,U;let q=this.chart,V=q.plotWidth,K=q.plotHeight,Z=this.options,_=Z.useSimulation,Q=Math.min(V,K),$={},J=[],tt=q.allDataPoints||[],et=tt.length;["minSize","maxSize"].forEach((G=>{let F=parseInt(Z[G],10),H=/%$/.test(Z[G]);$[G]=H?Q*F/100:F*Math.sqrt(et)})),q.minRadius=G=$.minSize/Math.sqrt(et),q.maxRadius=F=$.maxSize/Math.sqrt(et);let it=_?this.calculateZExtremes():[G,F];tt.forEach(((q,V)=>{H=_?at(q[2],it[0],it[1]):q[2],0===(U=this.getRadius(it[0],it[1],G,F,H))&&(U=null),tt[V][2]=U,J.push(U)})),this.radii=J}init(){return tt.init.apply(this,arguments),st.call(this),this.eventsToUnbind.push(ot(this,"updatedData",(function(){this.chart.series.forEach((G=>{G.type===this.type&&(G.isDirty=!0)}),this)}))),this}onMouseUp(G){if(G.fixedPosition&&!G.removed){let H;let U=this.layout,q=this.parentNodeLayout;q&&U.options.dragBetweenSeries&&q.nodes.forEach((F=>{G&&G.marker&&F!==G.series.parentNode&&(H=U.getDistXY(G,F),U.vectorLength(H)-F.marker.radius-G.marker.radius<0&&(F.series.addPoint(dt(G.options,{plotX:G.plotX,plotY:G.plotY}),!1),U.removeElementFromCollection(G,U.nodes),G.remove()))})),F.onMouseUp.apply(this,arguments)}}placeBubbles(G){let F,H,U=this.checkOverlap,q=this.positionBubble,V=[],K=1,Z=0,_=0,Q=[],$=G.sort(((G,F)=>F[2]-G[2]));if($.length){if(V.push([[0,0,$[0][2],$[0][3],$[0][4]]]),$.length>1)for(V.push([[0,0-$[1][2]-$[0][2],$[1][2],$[1][3],$[1][4]]]),H=2;H<$.length;H++)$[H][2]=$[H][2]||1,U(F=q(V[K][Z],V[K-1][_],$[H]),V[K][0])?(V.push([]),_=0,V[K+1].push(q(V[K][Z],V[K][0],$[H])),K++,Z=0):K>1&&V[K-1][_+1]&&U(F,V[K-1][_+1])?(_++,V[K].push(q(V[K][Z],V[K-1][_],$[H])),Z++):(Z++,V[K].push(F));this.chart.stages=V,this.chart.rawPositions=[].concat.apply([],V),this.resizeRadius(),Q=this.chart.rawPositions}return Q}pointAttribs(G,F){let H=this.options,U=G&&G.isParentNode,q=H.marker;U&&H.layoutAlgorithm&&H.layoutAlgorithm.parentNodeOptions&&(q=H.layoutAlgorithm.parentNodeOptions.marker);let V=q.fillOpacity,K=tt.pointAttribs.call(this,G,F);return 1!==V&&(K["fill-opacity"]=V),K}positionBubble(G,F,H){let U=Math.pow,q=(0,Math.sqrt)(U(G[0]-F[0],2)+U(G[1]-F[1],2)),V=(0,Math.acos)((U(q,2)+U(H[2]+F[2],2)-U(H[2]+G[2],2))/(2*(H[2]+F[2])*q)),K=(0,Math.asin)((0,Math.abs)(G[0]-F[0])/q),Z=G[1]-F[1]<0?0:Math.PI,_=(G[0]-F[0])*(G[1]-F[1])<0?1:-1,Q=Z+V+K*_,$=F[0]+(F[2]+H[2])*Math.sin(Q),J=F[1]-(F[2]+H[2])*Math.cos(Q);return[$,J,H[2],H[3],H[4]]}render(){let G=[];tt.render.apply(this,arguments),!this.options.dataLabels.allowOverlap&&(this.data.forEach((F=>{ht(F.dataLabels)&&F.dataLabels.forEach((F=>{G.push(F)}))})),this.options.useSimulation&&this.chart.hideOverlappingLabels(G))}resizeRadius(){let G,F,H,U,q;let V=this.chart,K=V.rawPositions,Z=Math.min,_=Math.max,Q=V.plotLeft,$=V.plotTop,J=V.plotHeight,tt=V.plotWidth;for(let V of(G=H=Number.POSITIVE_INFINITY,F=U=Number.NEGATIVE_INFINITY,K))q=V[2],G=Z(G,V[0]-q),F=_(F,V[0]+q),H=Z(H,V[1]-q),U=_(U,V[1]+q);let et=[F-G,U-H],it=[(tt-Q)/et[0],(J-$)/et[1]],st=Z.apply([],it);if(Math.abs(st-1)>1e-10){for(let G of K)G[2]*=st;this.placeBubbles(K)}else V.diffY=J/2+$-H-(U-H)/2,V.diffX=tt/2+Q-G-(F-G)/2}seriesBox(){let G;let F=this.chart,H=this.data,U=Math.max,q=Math.min,V=[F.plotLeft,F.plotLeft+F.plotWidth,F.plotTop,F.plotTop+F.plotHeight];return H.forEach((F=>{rt(F.plotX)&&rt(F.plotY)&&F.marker.radius&&(G=F.marker.radius,V[0]=q(V[0],F.plotX-G),V[1]=U(V[1],F.plotX+G),V[2]=q(V[2],F.plotY-G),V[3]=U(V[3],F.plotY+G))})),pt(V.width/V.height)?V:null}setVisible(){let G=this;tt.setVisible.apply(G,arguments),G.parentNodeLayout&&G.graph?G.visible?(G.graph.show(),G.parentNode.dataLabel&&G.parentNode.dataLabel.show()):(G.graph.hide(),G.parentNodeLayout.removeElementFromCollection(G.parentNode,G.parentNodeLayout.nodes),G.parentNode.dataLabel&&G.parentNode.dataLabel.hide()):G.layout&&(G.visible?G.layout.addElementsToCollection(G.points,G.layout.nodes):G.points.forEach((F=>{G.layout.removeElementFromCollection(F,G.layout.nodes)})))}translate(){let G,F,H;let U=this.chart,q=this.data,V=this.index,K=this.options.useSimulation;for(let Z of(this.processedXData=this.xData,this.generatePoints(),rt(U.allDataPoints)||(U.allDataPoints=this.accumulateAllPoints(),this.getPointRadius()),K?H=U.allDataPoints:(H=this.placeBubbles(U.allDataPoints),this.options.draggable=!1),H))Z[3]===V&&(G=q[Z[4]],F=ct(Z[2],void 0),K||(G.plotX=Z[0]-U.plotLeft+U.diffX,G.plotY=Z[1]-U.plotTop+U.diffY),pt(F)&&(G.marker=nt(G.marker,{radius:F,width:2*F,height:2*F}),G.radius=F));K&&this.deferLayout(),lt(this,"afterTranslate")}}return v.defaultOptions=dt(et.defaultOptions,V),nt(v.prototype,{pointClass:q,axisTypes:[],directTouch:!0,forces:["barycenter","repulsive"],hasDraggableNodes:!0,isCartesian:!1,noSharedTooltip:!0,pointArrayMap:["value"],pointValKey:"value",requireSorting:!1,trackerGroups:["group","dataLabelsGroup","parentNodesGroup"],initDataLabels:it,alignDataLabel:tt.alignDataLabel,indexateNodes:J,onMouseDown:F.onMouseDown,onMouseMove:F.onMouseMove,redrawHalo:F.redrawHalo,searchPoint:J}),Z.registerSeriesType("packedbubble",v),v})),i(H,"Series/Polygon/PolygonSeriesDefaults.js",[],(function(){return{marker:{enabled:!1,states:{hover:{enabled:!1}}},stickyTracking:!1,tooltip:{followPointer:!0,pointFormat:""},trackByArea:!0,legendSymbol:"rectangle"}})),i(H,"Series/Polygon/PolygonSeries.js",[H["Core/Globals.js"],H["Series/Polygon/PolygonSeriesDefaults.js"],H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"]],(function(G,F,H,U){let{noop:q}=G,{area:V,line:K,scatter:Z}=H.seriesTypes,{extend:_,merge:Q}=U;class p extends Z{getGraphPath(){let G=K.prototype.getGraphPath.call(this),F=G.length+1;for(;F--;)(F===G.length||"M"===G[F][0])&&F>0&&G.splice(F,0,["Z"]);return this.areaPath=G,G}drawGraph(){this.options.fillColor=this.color,V.prototype.drawGraph.call(this)}}return p.defaultOptions=Q(Z.defaultOptions,F),_(p.prototype,{type:"polygon",drawTracker:K.prototype.drawTracker,setStackedPoints:q}),H.registerSeriesType("polygon",p),p})),i(H,"Core/Axis/RadialAxis.js",[H["Core/Defaults.js"],H["Core/Globals.js"],H["Core/Utilities.js"]],(function(F,H,U){var q;let{defaultOptions:V}=F,{composed:K,noop:Z}=H,{addEvent:_,correctFloat:Q,defined:$,extend:J,fireEvent:tt,isObject:et,merge:it,pick:st,pushUnique:ot,relativeLength:at,wrap:rt}=U;return function(F){let H={gridLineWidth:1,labels:{align:void 0,x:0,y:void 0,style:{textOverflow:"none"}},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},U={endOnTick:!1,gridLineWidth:0,labels:{align:"center",distance:-25,x:0,y:void 0},lineWidth:1,minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickPosition:"inside",tickWidth:2,title:{rotation:0,text:""},zIndex:2},q={gridLineInterpolation:"circle",gridLineWidth:1,labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}};function y(){(this||G).autoConnect=(this||G).isCircular&&void 0===st((this||G).userMax,(this||G).options.max)&&Q((this||G).endAngleRad-(this||G).startAngleRad)===Q(2*Math.PI),!(this||G).isCircular&&(this||G).chart.inverted&&(this||G).max++,(this||G).autoConnect&&((this||G).max+=((this||G).categories?1:(this||G).pointRange)||(this||G).closestPointRange||0)}function x(){return()=>{if((this||G).isRadial&&(this||G).tickPositions&&(this||G).options.labels&&!0!==(this||G).options.labels.allowOverlap)return(this||G).tickPositions.map((F=>(this||G).ticks[F]&&(this||G).ticks[F].label)).filter((G=>!!G))}}function P(){return Z}function S(F,H,U){let q,V,K,Z=(this||G).pane.center,_=F.value;return(this||G).isCircular?($(_)?F.point&&(F.point.shapeArgs||{}).start&&(_=(this||G).chart.inverted?this.translate(F.point.rectPlotY,!0):F.point.x):(V=F.chartX||0,K=F.chartY||0,_=this.translate(Math.atan2(K-U,V-H)-(this||G).startAngleRad,!0)),V=(q=this.getPosition(_)).x,K=q.y):($(_)||(V=F.chartX,K=F.chartY),$(V)&&$(K)&&(U=Z[1]+(this||G).chart.plotTop,_=this.translate(Math.min(Math.sqrt(Math.pow(V-H,2)+Math.pow(K-U,2)),Z[2]/2)-Z[3]/2,!0))),[_,V||0,K||0]}function M(F,H,U){let q,V,K=(this||G).pane.center,Z=(this||G).chart,_=(this||G).left||0,Q=(this||G).top||0,$=st(H,K[2]/2-(this||G).offset);return void 0===U&&(U=(this||G).horiz?0:(this||G).center&&-(this||G).center[3]/2),U&&($+=U),(this||G).isCircular||void 0!==H?((V=(this||G).chart.renderer.symbols.arc(_+K[0],Q+K[1],$,$,{start:(this||G).startAngleRad,end:(this||G).endAngleRad,open:!0,innerR:0})).xBounds=[_+K[0]],V.yBounds=[Q+K[1]-$]):(q=this.postTranslate((this||G).angleRad,$),V=[["M",(this||G).center[0]+Z.plotLeft,(this||G).center[1]+Z.plotTop],["L",q.x,q.y]]),V}function L(){let F=(this||G).constructor.prototype;F.getOffset.call(this||G),(this||G).chart.axisOffset[(this||G).side]=0}function k(F,H,U){let q,V,K,Z,_,Q,$=(this||G).chart,o=G=>{if("string"==typeof G){let F=parseInt(G,10);return rt.test(G)&&(F=F*et/100),F}return G},J=(this||G).center,tt=(this||G).startAngleRad,et=J[2]/2,it=Math.min((this||G).offset,0),ot=(this||G).left||0,at=(this||G).top||0,rt=/%$/,nt=(this||G).isCircular,lt=st(o(U.outerRadius),et),ht=o(U.innerRadius),pt=st(o(U.thickness),10);if("polygon"===(this||G).options.gridLineInterpolation)Q=this.getPlotLinePath({value:F}).concat(this.getPlotLinePath({value:H,reverse:!0}));else{F=Math.max(F,(this||G).min),H=Math.min(H,(this||G).max);let et=this.translate(F),rt=this.translate(H);nt||(lt=et||0,ht=rt||0),"circle"!==U.shape&&nt?(q=tt+(et||0),V=tt+(rt||0)):(q=-Math.PI/2,V=1.5*Math.PI,_=!0),lt-=it,pt-=it,Q=$.renderer.symbols.arc(ot+J[0],at+J[1],lt,lt,{start:Math.min(q,V),end:Math.max(q,V),innerR:st(ht,lt-pt),open:_}),nt&&(K=(V+q)/2,Z=ot+J[0]+J[2]/2*Math.cos(K),Q.xBounds=K>-Math.PI/2&&K<Math.PI/2?[Z,$.plotWidth]:[0,Z],Q.yBounds=[at+J[1]+J[2]/2*Math.sin(K)],Q.yBounds[0]+=K>-Math.PI&&K<0||K>Math.PI?-10:10)}return Q}function v(F){let H,U,q,V,K,Z,_,Q,$,J=(this||G).pane.center,tt=(this||G).chart,et=tt.inverted,it=F.reverse,st=(this||G).pane.options.background?(this||G).pane.options.background[0]||(this||G).pane.options.background:{},ot=st.innerRadius||"0%",rt=st.outerRadius||"100%",nt=J[0]+tt.plotLeft,lt=J[1]+tt.plotTop,ht=(this||G).height,pt=F.isCrosshair,dt=J[3]/2,ct=F.value,ut=this.getPosition(ct),gt=ut.x,ft=ut.y;if(pt&&(ct=(Q=this.getCrosshairPosition(F,nt,lt))[0],gt=Q[1],ft=Q[2]),(this||G).isCircular)U=Math.sqrt(Math.pow(gt-nt,2)+Math.pow(ft-lt,2)),q="string"==typeof ot?at(ot,1):ot/U,V="string"==typeof rt?at(rt,1):rt/U,J&&dt&&(q<(H=dt/U)&&(q=H),V<H&&(V=H)),$=[["M",nt+q*(gt-nt),lt-q*(lt-ft)],["L",gt-(1-V)*(gt-nt),ft+(1-V)*(lt-ft)]];else if((ct=this.translate(ct))&&(ct<0||ct>ht)&&(ct=0),"circle"===(this||G).options.gridLineInterpolation)$=this.getLinePath(0,ct,dt);else if($=[],tt[et?"yAxis":"xAxis"].forEach((F=>{F.pane===(this||G).pane&&(K=F)})),K){_=K.tickPositions,K.autoConnect&&(_=_.concat([_[0]])),it&&(_=_.slice().reverse()),ct&&(ct+=dt);for(let G=0;G<_.length;G++)Z=K.getPosition(_[G],ct),$.push(G?["L",Z.x,Z.y]:["M",Z.x,Z.y])}return $}function C(F,H){let U=this.translate(F);return this.postTranslate((this||G).isCircular?U:(this||G).angleRad,st((this||G).isCircular?H:U<0?0:U,(this||G).center[2]/2)-(this||G).offset)}function w(){let F=(this||G).center,H=(this||G).chart,U=(this||G).options.title;return{x:H.plotLeft+F[0]+(U.x||0),y:H.plotTop+F[1]-{high:.5,middle:.25,low:0}[U.align]*F[2]+(U.y||0)}}function A(G){G.beforeSetTickPositions=y,G.createLabelCollector=x,G.getCrosshairPosition=S,G.getLinePath=M,G.getOffset=L,G.getPlotBandPath=k,G.getPlotLinePath=v,G.getPosition=C,G.getTitlePosition=w,G.postTranslate=D,G.setAxisSize=B,G.setAxisTranslation=z,G.setOptions=O}function N(){let F=(this||G).chart,H=(this||G).options,U=F.angular&&(this||G).isXAxis,q=(this||G).pane,V=q&&q.options;if(!U&&q&&(F.angular||F.polar)){let F=2*Math.PI,U=(st(V.startAngle,0)-90)*Math.PI/180,q=(st(V.endAngle,st(V.startAngle,0)+360)-90)*Math.PI/180;(this||G).angleRad=(H.angle||0)*Math.PI/180,(this||G).startAngleRad=U,(this||G).endAngleRad=q,(this||G).offset=H.offset||0;let K=(U%F+F)%F,Z=(q%F+F)%F;K>Math.PI&&(K-=F),Z>Math.PI&&(Z-=F),(this||G).normalizedStartAngleRad=K,(this||G).normalizedEndAngleRad=Z}}function T(F){(this||G).isRadial&&(F.align=void 0,F.preventDefault())}function X(){if((this||G).chart&&(this||G).chart.labelCollectors){let F=(this||G).labelCollector?(this||G).chart.labelCollectors.indexOf((this||G).labelCollector):-1;F>=0&&(this||G).chart.labelCollectors.splice(F,1)}}function Y(F){let H;let U=(this||G).chart,q=(U.inverted,U.angular),V=U.polar,K=(this||G).isXAxis,_=(this||G).coll,Q=F.userOptions.pane||0,$=(this||G).pane=U.pane&&U.pane[Q];"colorAxis"!==_?(q?(q&&K?((this||G).isHidden=!0,(this||G).createLabelCollector=P,(this||G).getOffset=Z,(this||G).redraw=E,(this||G).render=E,(this||G).setScale=Z,(this||G).setCategories=Z,(this||G).setTitle=Z):A(this||G),H=!K):V&&(A(this||G),H=(this||G).horiz),q||V?((this||G).isRadial=!0,(this||G).labelCollector||((this||G).labelCollector=this.createLabelCollector()),(this||G).labelCollector&&U.labelCollectors.push((this||G).labelCollector)):(this||G).isRadial=!1,$&&H&&($.axis=this||G),(this||G).isCircular=H):(this||G).isRadial=!1}function R(){(this||G).isRadial&&this.beforeSetTickPositions()}function I(F){let H=(this||G).label;if(!H)return;let U,q=(this||G).axis,V=H.getBBox(),K=q.options.labels,Z=(q.translate((this||G).pos)+q.startAngleRad+Math.PI/2)/Math.PI*180%360,_=Math.round(Z),Q=$(K.y)?0:-.3*V.height,J=K.y,tt=20,et=K.align,it="end",ot=_<0?_+360:_,rt=ot,nt=0,lt=0;q.isRadial&&(U=q.getPosition((this||G).pos,q.center[2]/2+at(st(K.distance,-25),q.center[2]/2,-q.center[2]/2)),"auto"===K.rotation?H.attr({rotation:Z}):$(J)||(J=q.chart.renderer.fontMetrics(H).b-V.height/2),$(et)||(q.isCircular?(V.width>q.len*q.tickInterval/(q.max-q.min)&&(tt=0),et=Z>tt&&Z<180-tt?"left":Z>180+tt&&Z<360-tt?"right":"center"):et="center",H.attr({align:et})),"auto"===et&&2===q.tickPositions.length&&q.isCircular&&(ot>90&&ot<180?ot=180-ot:ot>270&&ot<=360&&(ot=540-ot),rt>180&&rt<=360&&(rt=360-rt),(q.pane.options.startAngle===_||q.pane.options.startAngle===_+360||q.pane.options.startAngle===_-360)&&(it="start"),et=_>=-90&&_<=90||_>=-360&&_<=-270||_>=270&&_<=360?"start"===it?"right":"left":"start"===it?"left":"right",rt>70&&rt<110&&(et="center"),ot<15||ot>=180&&ot<195?nt=.3*V.height:ot>=15&&ot<=35?nt="start"===it?0:.75*V.height:ot>=195&&ot<=215?nt="start"===it?.75*V.height:0:ot>35&&ot<=90?nt="start"===it?-.25*V.height:V.height:ot>215&&ot<=270&&(nt="start"===it?V.height:-.25*V.height),rt<15?lt="start"===it?-.15*V.height:.15*V.height:rt>165&&rt<=180&&(lt="start"===it?.15*V.height:-.15*V.height),H.attr({align:et}),H.translate(lt,nt+Q)),F.pos.x=U.x+(K.x||0),F.pos.y=U.y+(J||0))}function j(F){(this||G).axis.getPosition&&J(F.pos,(this||G).axis.getPosition((this||G).pos))}function D(F,H){let U=(this||G).chart,q=(this||G).center;return F=(this||G).startAngleRad+F,{x:U.plotLeft+q[0]+Math.cos(F)*H,y:U.plotTop+q[1]+Math.sin(F)*H}}function E(){(this||G).isDirty=!1}function B(){let F,H;let U=(this||G).constructor.prototype;U.setAxisSize.call(this||G),(this||G).isRadial&&((this||G).pane.updateCenter(this||G),F=(this||G).center=(this||G).pane.center.slice(),(this||G).isCircular?(this||G).sector=(this||G).endAngleRad-(this||G).startAngleRad:(H=this.postTranslate((this||G).angleRad,F[3]/2),F[0]=H.x-(this||G).chart.plotLeft,F[1]=H.y-(this||G).chart.plotTop),(this||G).len=(this||G).width=(this||G).height=(F[2]-F[3])*st((this||G).sector,1)/2)}function z(){let F=(this||G).constructor.prototype;F.setAxisTranslation.call(this||G),(this||G).center&&((this||G).isCircular?(this||G).transA=((this||G).endAngleRad-(this||G).startAngleRad)/((this||G).max-(this||G).min||1):(this||G).transA=((this||G).center[2]-(this||G).center[3])/2/((this||G).max-(this||G).min||1),(this||G).isXAxis?(this||G).minPixelPadding=(this||G).transA*(this||G).minPointOffset:(this||G).minPixelPadding=0)}function O(F){let{coll:K}=this||G,{angular:Z,inverted:_,polar:Q}=(this||G).chart,$={};Z?(this||G).isXAxis||($=it(V.yAxis,U)):Q&&($=(this||G).horiz?it(V.xAxis,H):it("xAxis"===K?V.xAxis:V.yAxis,q)),_&&"yAxis"===K&&($.stackLabels=et(V.yAxis,!0)?V.yAxis.stackLabels:{},$.reversedStacks=!0);let J=(this||G).options=it($,F);J.plotBands||(J.plotBands=[]),tt(this||G,"afterSetOptions")}function W(F,H,U,q,V,K,Z){let _;let Q=(this||G).axis;return Q.isRadial?["M",H,U,"L",(_=Q.getPosition((this||G).pos,Q.center[2]/2+q)).x,_.y]:F.call(this||G,H,U,q,V,K,Z)}F.compose=function t(G,F){return ot(K,t)&&(_(G,"afterInit",N),_(G,"autoLabelAlign",T),_(G,"destroy",X),_(G,"init",Y),_(G,"initialAxisTranslation",R),_(F,"afterGetLabelPosition",I),_(F,"afterGetPosition",j),rt(F.prototype,"getMarkPath",W)),G}}(q||(q={})),q})),i(H,"Series/PolarComposition.js",[H["Core/Animation/AnimationUtilities.js"],H["Core/Globals.js"],H["Core/Series/Series.js"],H["Extensions/Pane/Pane.js"],H["Core/Axis/RadialAxis.js"],H["Core/Utilities.js"]],(function(F,H,U,q,V,K){let{animObject:Z}=F,{composed:_}=H,{addEvent:Q,defined:$,find:J,isNumber:tt,merge:et,pick:it,pushUnique:st,relativeLength:ot,splat:at,uniqueKey:rt,wrap:nt}=K;function x(){((this||G).pane||[]).forEach((G=>{G.render()}))}function P(G){let F=G.args[0].xAxis,H=G.args[0].yAxis,U=G.args[0].chart;F&&H&&("polygon"===H.gridLineInterpolation?(F.startOnTick=!0,F.endOnTick=!0):"polygon"===F.gridLineInterpolation&&U.inverted&&(H.startOnTick=!0,H.endOnTick=!0))}function S(){(this||G).pane||((this||G).pane=[]),(this||G).options.pane=at((this||G).options.pane),(this||G).options.pane.forEach((F=>{new q(F,this||G)}),this||G)}function M(F){let H=F.args.marker,U=(this||G).chart.xAxis[0],q=(this||G).chart.yAxis[0],V=(this||G).chart.inverted,K=V?q:U,Z=V?U:q;if((this||G).chart.polar){F.preventDefault();let G=(H.attr?H.attr("start"):H.start)-K.startAngleRad,U=H.attr?H.attr("r"):H.r,q=(H.attr?H.attr("end"):H.end)-K.startAngleRad,V=H.attr?H.attr("innerR"):H.innerR;F.result.x=G+K.pos,F.result.width=q-G,F.result.y=Z.len+Z.pos-V,F.result.height=V-U}}function L(F){let H=(this||G).chart;if(H.polar&&H.hoverPane&&H.hoverPane.axis){F.preventDefault();let U=H.hoverPane.center,q=(this||G).mouseDownX||0,V=(this||G).mouseDownY||0,K=F.args.chartY,Z=F.args.chartX,_=2*Math.PI,Q=H.hoverPane.axis.startAngleRad,$=H.hoverPane.axis.endAngleRad,J=H.inverted?H.xAxis[0]:H.yAxis[0],tt={},et="arc";if(tt.x=U[0]+H.plotLeft,tt.y=U[1]+H.plotTop,(this||G).zoomHor){let G=Q>0?$-Q:Math.abs(Q)+Math.abs($),F=Math.atan2(V-H.plotTop-U[1],q-H.plotLeft-U[0])-Q,it=Math.atan2(K-H.plotTop-U[1],Z-H.plotLeft-U[0])-Q;if(tt.r=U[2]/2,tt.innerR=U[3]/2,F<=0&&(F+=_),it<=0&&(it+=_),it<F&&(it=[F,F=it][0]),G<_){let H=$+(_-G)/2;Q+it>H&&(it=F,F=Q<=0?Q:0)}let st=tt.start=Math.max(F+Q,Q),ot=tt.end=Math.min(it+Q,$);if("polygon"===J.options.gridLineInterpolation){let G=H.hoverPane.axis,F=(G.tickInterval,st-G.startAngleRad+G.pos),q=J.getPlotLinePath({value:J.max}),V=G.toValue(F),K=G.toValue(F+(ot-st));if(V<G.getExtremes().min){let{min:F,max:H}=G.getExtremes();V=H-(F-V)}if(K<G.getExtremes().min){let{min:F,max:H}=G.getExtremes();K=H-(F-K)}K<V&&(K=[V,V=K][0]),(q=w(q,V,K,G)).push(["L",U[0]+H.plotLeft,H.plotTop+U[1]]),tt.d=q,et="path"}}if((this||G).zoomVert){let F=H.inverted?H.xAxis[0]:H.yAxis[0],_=Math.sqrt(Math.pow(q-H.plotLeft-U[0],2)+Math.pow(V-H.plotTop-U[1],2)),J=Math.sqrt(Math.pow(Z-H.plotLeft-U[0],2)+Math.pow(K-H.plotTop-U[1],2));if(J<_&&(_=[J,J=_][0]),J>U[2]/2&&(J=U[2]/2),_<U[3]/2&&(_=U[3]/2),(this||G).zoomHor||(tt.start=Q,tt.end=$),tt.r=J,tt.innerR=_,"polygon"===F.options.gridLineInterpolation){let G=F.toValue(F.len+F.pos-_),H=F.toValue(F.len+F.pos-J),U=F.getPlotLinePath({value:H}).concat(F.getPlotLinePath({value:G,reverse:!0}));tt.d=U,et="path"}}if((this||G).zoomHor&&(this||G).zoomVert&&"polygon"===J.options.gridLineInterpolation){let G=H.hoverPane.axis,F=tt.start||0,U=tt.end||0,q=F-G.startAngleRad+G.pos,V=G.toValue(q),K=G.toValue(q+(U-F));if(tt.d instanceof Array){let G=tt.d.slice(0,tt.d.length/2),F=tt.d.slice(tt.d.length/2,tt.d.length);F=[...F].reverse();let U=H.hoverPane.axis;G=w(G,V,K,U),(F=w(F,V,K,U))&&(F[0][0]="L"),F=[...F].reverse(),tt.d=G.concat(F),et="path"}}F.attrs=tt,F.shapeType=et}}function k(){let F=(this||G).chart;F.polar&&((this||G).polar=new E(this||G),F.inverted&&((this||G).isRadialSeries=!0,this.is("column")&&((this||G).isRadialBar=!0)))}function v(){if((this||G).chart.polar&&(this||G).xAxis){let{xAxis:F,yAxis:U}=this||G,q=(this||G).chart;(this||G).kdByAngle=q.tooltip&&q.tooltip.shared,(this||G).kdByAngle||q.inverted?(this||G).searchPoint=C:(this||G).options.findNearestPointBy="xy";let V=(this||G).points,K=V.length;for(;K--;)this.is("column")||this.is("columnrange")||(this||G).polar.toXY(V[K]),q.hasParallelCoordinates||(this||G).yAxis.reversed||(it(V[K].y,Number.MIN_VALUE)<U.min||V[K].x<F.min||V[K].x>F.max?(V[K].isNull=!0,V[K].plotY=NaN):V[K].isNull=V[K].isValid&&!V[K].isValid());(this||G).hasClipCircleSetter||((this||G).hasClipCircleSetter=!!(this||G).eventsToUnbind.push(Q(this||G,"afterRender",(function(){let F;q.polar&&!1!==(this||G).options.clip&&(F=(this||G).yAxis.pane.center,(this||G).clipCircle?(this||G).clipCircle.animate({x:F[0],y:F[1],r:F[2]/2,innerR:F[3]/2}):(this||G).clipCircle=function(G,F,H,U,q){let V=rt(),K=G.createElement("clipPath").attr({id:V}).add(G.defs),Z=q?G.arc(F,H,U,q,0,2*Math.PI).add(K):G.circle(F,H,U).add(K);return Z.id=V,Z.clipPath=K,Z}(q.renderer,F[0],F[1],F[2]/2,F[3]/2),(this||G).group.clip((this||G).clipCircle),(this||G).setClip=H.noop)}))))}}function C(F){let H=(this||G).chart,U=(this||G).xAxis,q=(this||G).yAxis,V=U.pane&&U.pane.center,K=F.chartX-(V&&V[0]||0)-H.plotLeft,Z=F.chartY-(V&&V[1]||0)-H.plotTop,_=H.inverted?{clientX:F.chartX-q.pos,plotY:F.chartY-U.pos}:{clientX:180+Math.atan2(K,Z)*(-180/Math.PI)};return this.searchKDTree(_)}function w(G,F,H,U){let q=U.tickInterval,V=U.tickPositions,K=J(V,(G=>G>=H)),Z=J([...V].reverse(),(G=>G<=F));return $(K)||(K=V[V.length-1]),$(Z)||(Z=V[0],K+=q,G[0][0]="L",G.unshift(G[G.length-3])),(G=G.slice(V.indexOf(Z),V.indexOf(K)+1))[0][0]="M",G}function A(F,H){return J((this||G).pane||[],(G=>G.options.id===H))||F.call(this||G,H)}function N(F,H,q,V,K,Z){let _,Q,$;let J=(this||G).chart,tt=it(V.inside,!!(this||G).options.stacking);if(J.polar){if(_=H.rectPlotX/Math.PI*180,J.inverted)(this||G).forceDL=J.isInsidePlot(H.plotX,H.plotY),tt&&H.shapeArgs?(Q=H.shapeArgs,K=et(K,{x:($=(this||G).yAxis.postTranslate(((Q.start||0)+(Q.end||0))/2-(this||G).xAxis.startAngleRad,H.barX+H.pointWidth/2)).x-J.plotLeft,y:$.y-J.plotTop})):H.tooltipPos&&(K=et(K,{x:H.tooltipPos[0],y:H.tooltipPos[1]})),V.align=it(V.align,"center"),V.verticalAlign=it(V.verticalAlign,"middle");else{var st;null===(st=V).align&&(st.align=_>20&&_<160?"left":_>200&&_<340?"right":"center"),null===st.verticalAlign&&(st.verticalAlign=_<45||_>315?"bottom":_>135&&_<225?"top":"middle"),V=st}U.prototype.alignDataLabel.call(this||G,H,q,V,K,Z),(this||G).isRadialBar&&H.shapeArgs&&H.shapeArgs.start===H.shapeArgs.end?q.hide():q.show()}else F.call(this||G,H,q,V,K,Z)}function T(){let F,H,U,q,V,Z,_,Q,J,et,it,st,at,rt=(this||G).options,nt=rt.stacking,lt=(this||G).chart,ht=(this||G).xAxis,pt=(this||G).yAxis,dt=pt.reversed,ct=pt.center,ut=ht.startAngleRad,gt=ht.endAngleRad,ft=gt-ut,mt=rt.threshold,bt=0,yt=0,xt=0;if(ht.isRadial)for(U=(F=(this||G).points).length,q=pt.translate(pt.min),V=pt.translate(pt.max),mt=rt.threshold||0,lt.inverted&&tt(mt)&&$(bt=pt.translate(mt))&&(bt<0?bt=0:bt>ft&&(bt=ft),(this||G).translatedThreshold=bt+ut);U--;){if(it=(H=F[U]).barX,_=H.x,Q=H.y,H.shapeType="arc",lt.inverted){H.plotY=pt.translate(Q),nt&&pt.stacking?(et=pt.stacking.stacks[(Q<0?"-":"")+(this||G).stackKey],(this||G).visible&&et&&et[_]&&!H.isNull&&(J=et[_].points[this.getStackIndicator(void 0,_,(this||G).index).key],yt=pt.translate(J[0]),xt=pt.translate(J[1]),$(yt)&&(yt=K.clamp(yt,0,ft)))):(yt=bt,xt=H.plotY),yt>xt&&(xt=[yt,yt=xt][0]),dt?xt>q?xt=q:yt<V?yt=V:(yt>q||xt<V)&&(yt=xt=ft):yt<q?yt=q:xt>V?xt=V:(xt<q||yt>V)&&(yt=xt=0),pt.min>pt.max&&(yt=xt=dt?ft:0),yt+=ut,xt+=ut,ct&&(H.barX=it+=ct[3]/2),st=Math.max(it,0),at=Math.max(it+H.pointWidth,0);let F=rt.borderRadius,U="object"==typeof F?F.radius:F,Z=ot(U||0,at-st);H.shapeArgs={x:ct[0],y:ct[1],r:at,innerR:st,start:yt,end:xt,borderRadius:Z},H.opacity=yt===xt?0:void 0,H.plotY=($((this||G).translatedThreshold)&&(yt<(this||G).translatedThreshold?yt:xt))-ut}else yt=it+ut,H.shapeArgs=(this||G).polar.arc(H.yBottom,H.plotY,yt,yt+H.pointWidth),H.shapeArgs.borderRadius=0;(this||G).polar.toXY(H),lt.inverted?(Z=pt.postTranslate(H.rectPlotY,it+H.pointWidth/2),H.tooltipPos=[Z.x-lt.plotLeft,Z.y-lt.plotTop]):H.tooltipPos=[H.plotX,H.plotY],ct&&(H.ttBelow=H.plotY>ct[1])}}function X(F,H){let U,q;let V=this||G;if((this||G).chart.polar){H=H||(this||G).points;for(let G=0;G<H.length;G++)if(!H[G].isNull){U=G;break}!1!==(this||G).options.connectEnds&&void 0!==U&&((this||G).connectEnds=!0,H.splice(H.length,0,H[U]),q=!0),H.forEach((G=>{void 0===G.polarPlotY&&V.polar.toXY(G)}))}let K=F.apply(this||G,[].slice.call(arguments,1));return q&&H.pop(),K}function Y(F,H){let U=(this||G).chart,q={xAxis:[],yAxis:[]};return U.polar?U.axes.forEach((G=>{if("colorAxis"===G.coll)return;let F=G.isXAxis,V=G.center,K=H.chartX-V[0]-U.plotLeft,Z=H.chartY-V[1]-U.plotTop;q[F?"xAxis":"yAxis"].push({axis:G,value:G.translate(F?Math.PI-Math.atan2(K,Z):Math.sqrt(Math.pow(K,2)+Math.pow(Z,2)),!0)})})):q=F.call(this||G,H),q}function R(F,H){(this||G).chart.polar||F.call(this||G,H)}function I(F,U){let q,V,K,_,Q,$,J=this||G,tt=(this||G).chart,et=(this||G).group,st=(this||G).markerGroup,ot=(this||G).xAxis&&(this||G).xAxis.center,at=tt.plotLeft,rt=tt.plotTop,nt=(this||G).options.animation;tt.polar?J.isRadialBar?U||(J.startAngleRad=it(J.translatedThreshold,J.xAxis.startAngleRad),H.seriesTypes.pie.prototype.animate.call(J,U)):(nt=Z(nt),J.is("column")?U||(V=ot[3]/2,J.points.forEach((G=>{K=G.graphic,Q=(_=G.shapeArgs)&&_.r,$=_&&_.innerR,K&&_&&(K.attr({r:V,innerR:V}),K.animate({r:Q,innerR:$},J.options.animation))}))):U?(q={translateX:ot[0]+at,translateY:ot[1]+rt,scaleX:.001,scaleY:.001},et.attr(q),st&&st.attr(q)):(q={translateX:at,translateY:rt,scaleX:1,scaleY:1},et.animate(q,nt),st&&st.animate(q,nt))):F.call(this||G,U)}function j(F,H,U,q){let V,K;if((this||G).chart.polar)if(q){K=function t(G,F,H,U){let q,V,K,Z,_,Q;let $=U?1:0;q=F>=0&&F<=G.length-1?F:F<0?G.length-1+F:0;let J=q-1<0?G.length-(1+$):q-1,tt=q+1>G.length-1?$:q+1,et=G[J],it=G[tt],st=et.plotX,ot=et.plotY,at=it.plotX,rt=it.plotY,nt=G[q].plotX,lt=G[q].plotY;V=(1.5*nt+st)/2.5,K=(1.5*lt+ot)/2.5,Z=(1.5*nt+at)/2.5,_=(1.5*lt+rt)/2.5;let ht=Math.sqrt(Math.pow(V-nt,2)+Math.pow(K-lt,2)),pt=Math.sqrt(Math.pow(Z-nt,2)+Math.pow(_-lt,2)),dt=Math.atan2(K-lt,V-nt),ct=Math.atan2(_-lt,Z-nt);Q=Math.PI/2+(dt+ct)/2,Math.abs(dt-Q)>Math.PI/2&&(Q-=Math.PI),V=nt+Math.cos(Q)*ht,K=lt+Math.sin(Q)*ht,Z=nt+Math.cos(Math.PI+Q)*pt,_=lt+Math.sin(Math.PI+Q)*pt;let ut={rightContX:Z,rightContY:_,leftContX:V,leftContY:K,plotX:nt,plotY:lt};return H&&(ut.prevPointCont=t(G,J,!1,U)),ut}(H,q,!0,(this||G).connectEnds);let F=K.prevPointCont&&K.prevPointCont.rightContX,U=K.prevPointCont&&K.prevPointCont.rightContY;V=["C",tt(F)?F:K.plotX,tt(U)?U:K.plotY,tt(K.leftContX)?K.leftContX:K.plotX,tt(K.leftContY)?K.leftContY:K.plotY,K.plotX,K.plotY]}else V=["M",U.plotX,U.plotY];else V=F.call(this||G,H,U,q);return V}function D(F,H,U=(this||G).plotY){let{plotX:q,series:V}=this||G,{chart:K}=V;return K.polar&&!(this||G).destroyed&&tt(q)&&tt(U)?[q+(H?K.plotLeft:0),U+(H?K.plotTop:0)]:F.call(this||G,H,U)}class E{static compose(G,F,H,U,K,Z,$,J,tt,et){if(q.compose(F,H),V.compose(G,K),st(_,this.compose)){let G=F.prototype,q=Z.prototype,V=H.prototype,K=U.prototype;if(Q(F,"afterDrawChartBox",x),Q(F,"getAxes",S),Q(F,"init",P),nt(G,"get",A),nt(V,"getCoordinates",Y),nt(V,"pinch",R),Q(H,"getSelectionMarkerAttrs",L),Q(H,"getSelectionBox",M),Q(U,"afterInit",k),Q(U,"afterTranslate",v,{order:2}),Q(U,"afterColumnTranslate",T,{order:4}),nt(K,"animate",I),nt(q,"pos",D),J){let G=J.prototype;nt(G,"alignDataLabel",N),nt(G,"animate",I)}if(tt){let G=tt.prototype;nt(G,"getGraphPath",X)}if(et){let G=et.prototype;if(nt(G,"getPointSpline",j),$){let F=$.prototype;F.getPointSpline=G.getPointSpline}}}}constructor(G){this.series=G}arc(G,F,H,U){let q=this.series,V=q.xAxis.center,K=q.yAxis.len,Z=V[3]/2,_=K-F+Z,Q=K-it(G,K)+Z;return q.yAxis.reversed&&(_<0&&(_=Z),Q<0&&(Q=Z)),{x:V[0],y:V[1],r:_,innerR:Q,start:H,end:U}}toXY(G){let F,H=this.series,U=H.chart,q=H.xAxis,V=H.yAxis,K=G.plotX,Z=U.inverted,_=G.y,Q=G.plotY,$=Z?K:V.len-Q;if(Z&&H&&!H.isRadialBar&&(G.plotY=Q=tt(_)?V.translate(_):0),G.rectPlotX=K,G.rectPlotY=Q,V.center&&($+=V.center[3]/2),tt(Q)){let F=Z?V.postTranslate(Q,$):q.postTranslate(K,$);G.plotX=G.polarPlotX=F.x-U.plotLeft,G.plotY=G.polarPlotY=F.y-U.plotTop}H.kdByAngle?((F=(K/Math.PI*180+q.pane.options.startAngle)%360)<0&&(F+=360),G.clientX=F):G.clientX=G.plotX}}return E})),i(H,"Core/Axis/WaterfallAxis.js",[H["Core/Globals.js"],H["Core/Axis/Stacking/StackItem.js"],H["Core/Utilities.js"]],(function(F,H,U){var q;let{composed:V}=F,{addEvent:K,objectEach:Z,pushUnique:_}=U;return function(F){function i(){let F=(this||G).waterfall.stacks;F&&(F.changed=!1,delete F.alreadyChanged)}function s(){let F=(this||G).options.stackLabels;F&&F.enabled&&(this||G).waterfall.stacks&&(this||G).waterfall.renderStackTotals()}function l(){(this||G).waterfall||((this||G).waterfall=new p(this||G))}function h(){let F=(this||G).axes,H=(this||G).series;for(let G of H)if(G.options.stacking){for(let G of F)G.isXAxis||(G.waterfall.stacks.changed=!0);break}}F.compose=function t(G,F){_(V,t)&&(K(G,"init",l),K(G,"afterBuildStacks",i),K(G,"afterRender",s),K(F,"beforeRedraw",h))};class p{constructor(G){this.axis=G,this.stacks={changed:!1}}renderStackTotals(){let G=this.axis,F=G.waterfall.stacks,U=G.stacking&&G.stacking.stackTotalGroup,q=new H(G,G.options.stackLabels||{},!1,0,void 0);this.dummyStackItem=q,U&&Z(F,(G=>{Z(G,((G,F)=>{q.total=G.stackTotal,q.x=+F,G.label&&(q.label=G.label),H.prototype.render.call(q,U),G.label=q.label,delete q.label}))})),q.total=null}}F.Composition=p}(q||(q={})),q})),i(H,"Series/Waterfall/WaterfallPoint.js",[H["Series/Column/ColumnSeries.js"],H["Core/Series/Point.js"],H["Core/Utilities.js"]],(function(G,F,H){let{isNumber:U}=H;class o extends G.prototype.pointClass{getClassName(){let G=F.prototype.getClassName.call(this);return this.isSum?G+=" highcharts-sum":this.isIntermediateSum&&(G+=" highcharts-intermediate-sum"),G}isValid(){return U(this.y)||this.isSum||!!this.isIntermediateSum}}return o})),i(H,"Series/Waterfall/WaterfallSeriesDefaults.js",[],(function(){return{dataLabels:{inside:!0},lineWidth:1,lineColor:"#333333",dashStyle:"Dot",borderColor:"#333333",states:{hover:{lineWidthPlus:0}}}})),i(H,"Series/Waterfall/WaterfallSeries.js",[H["Core/Series/SeriesRegistry.js"],H["Core/Utilities.js"],H["Core/Axis/WaterfallAxis.js"],H["Series/Waterfall/WaterfallPoint.js"],H["Series/Waterfall/WaterfallSeriesDefaults.js"]],(function(F,H,U,q,V){let{column:K,line:Z}=F.seriesTypes,{addEvent:_,arrayMax:Q,arrayMin:$,correctFloat:J,extend:tt,isNumber:et,merge:it,objectEach:st,pick:ot}=H;function b(G,F){return Object.hasOwnProperty.call(G,F)}class m extends K{generatePoints(){K.prototype.generatePoints.apply(this);for(let G=0,F=this.points.length;G<F;G++){let F=this.points[G],H=this.processedYData[G];et(H)&&(F.isIntermediateSum||F.isSum)&&(F.y=J(H))}}processData(G){let F,H,U,q,V,K;let Z=this.options,_=this.yData,Q=Z.data,$=_.length,tt=Z.threshold||0;U=H=q=V=0;for(let G=0;G<$;G++)K=_[G],F=Q&&Q[G]?Q[G]:{},"sum"===K||F.isSum?_[G]=J(U):"intermediateSum"===K||F.isIntermediateSum?(_[G]=J(H),H=0):(U+=K,H+=K),q=Math.min(U,q),V=Math.max(U,V);super.processData.call(this,G),Z.stacking||(this.dataMin=q+tt,this.dataMax=V)}toYData(G){return G.isSum?"sum":G.isIntermediateSum?"intermediateSum":G.y}updateParallelArrays(G,F){super.updateParallelArrays.call(this,G,F),("sum"===this.yData[0]||"intermediateSum"===this.yData[0])&&(this.yData[0]=null)}pointAttribs(G,F){let H=this.options.upColor;H&&!G.options.color&&et(G.y)&&(G.color=G.y>0?H:void 0);let U=K.prototype.pointAttribs.call(this,G,F);return delete U.dashstyle,U}getGraphPath(){return[["M",0,0]]}getCrispPath(){let G=this.data.filter((G=>et(G.y))),F=this.yAxis,H=G.length,U=Math.round(this.graph.strokeWidth())%2/2,q=Math.round(this.borderWidth)%2/2,V=this.xAxis.reversed,K=this.yAxis.reversed,Z=this.options.stacking,_=[];for(let Q=1;Q<H;Q++){if(!(this.options.connectNulls||et(this.data[G[Q].index-1].y)))continue;let H=G[Q].box,$=G[Q-1],J=$.y||0,tt=G[Q-1].box;if(!H||!tt)continue;let it=F.waterfall.stacks[this.stackKey],st=J>0?-tt.height:0;if(it&&tt&&H){let G;let J=it[Q-1];if(Z){let H=J.connectorThreshold;G=Math.round(F.translate(H,!1,!0,!1,!0)+(K?st:0))-U}else G=tt.y+$.minPointLengthOffset+q-U;_.push(["M",(tt.x||0)+(V?0:tt.width||0),G],["L",(H.x||0)+(V&&H.width||0),G])}if(tt&&_.length&&(!Z&&J<0&&!K||J>0&&K)){let G=_[_.length-2];G&&"number"==typeof G[2]&&(G[2]+=tt.height||0);let F=_[_.length-1];F&&"number"==typeof F[2]&&(F[2]+=tt.height||0)}}return _}drawGraph(){Z.prototype.drawGraph.call(this),this.graph&&this.graph.attr({d:this.getCrispPath()})}setStackedPoints(G){let F,H,U,q,V,K,Z,_,Q,$=this.options,J=G.waterfall?.stacks,tt=$.threshold||0,et=this.stackKey,it=this.xData,st=it.length,ot=tt,at=ot,rt=0,nt=0,lt=0,S=(G,U,q,V)=>{if(F){if(H)for(;q<H;q++)F.stackState[q]+=V;else F.stackState[0]=G,H=F.stackState.length;F.stackState.push(F.stackState[H-1]+U)}};if(G.stacking&&J&&this.reserveSpace()){Q=J.changed,(_=J.alreadyChanged)&&0>_.indexOf(et)&&(Q=!0),J[et]||(J[et]={});let G=J[et];if(G)for(let _=0;_<st;_++)(!G[Z=it[_]]||Q)&&(G[Z]={negTotal:0,posTotal:0,stackTotal:0,threshold:0,stateIndex:0,stackState:[],label:Q&&G[Z]?G[Z].label:void 0}),F=G[Z],(K=this.yData[_])>=0?F.posTotal+=K:F.negTotal+=K,V=$.data[_],U=F.absolutePos=F.posTotal,q=F.absoluteNeg=F.negTotal,F.stackTotal=U+q,H=F.stackState.length,V&&V.isIntermediateSum?(S(lt,nt,0,lt),lt=nt,nt=tt,ot^=at,at^=ot,ot^=at):V&&V.isSum?(S(tt,rt,H,0),ot=tt):(S(ot,K,0,rt),V&&(rt+=K,nt+=K)),F.stateIndex++,F.threshold=ot,ot+=F.stackTotal;J.changed=!1,J.alreadyChanged||(J.alreadyChanged=[]),J.alreadyChanged.push(et)}}getExtremes(){let G,F,H;let U=this.options.stacking;return U?(G=this.yAxis.waterfall.stacks,F=this.stackedYNeg=[],H=this.stackedYPos=[],st(G[this.stackKey],"overlap"===U?function(G){F.push($(G.stackState)),H.push(Q(G.stackState))}:function(G){F.push(G.negTotal+G.threshold),H.push(G.posTotal+G.threshold)}),{dataMin:$(F),dataMax:Q(H)}):{dataMin:this.dataMin,dataMax:this.dataMax}}}return m.defaultOptions=it(K.defaultOptions,V),m.compose=U.compose,tt(m.prototype,{pointValKey:"y",showLine:!0,pointClass:q}),_(m,"afterColumnTranslate",(function(){let F,H,U,q,{options:V,points:K,yAxis:Z}=this||G,_=ot(V.minPointLength,5),Q=_/2,$=V.threshold||0,J=V.stacking,st=Z.waterfall.stacks[(this||G).stackKey],at=$,rt=$;for(let V=0;V<K.length;V++){let ot=K[V],nt=(this||G).processedYData[V],lt=ot.shapeArgs,ht=tt({x:0,y:0,width:0,height:0},lt||{});ot.box=ht;let pt=[0,nt],dt=ot.y||0;if(J){if(st){let K=st[V];"overlap"===J?(H=K.stackState[K.stateIndex--],F=dt>=0?H:H-dt,b(K,"absolutePos")&&delete K.absolutePos,b(K,"absoluteNeg")&&delete K.absoluteNeg):(dt>=0?(H=K.threshold+K.posTotal,K.posTotal-=dt,F=H):(H=K.threshold+K.negTotal,K.negTotal-=dt,F=H-dt),!K.posTotal&&et(K.absolutePos)&&b(K,"absolutePos")&&(K.posTotal=K.absolutePos,delete K.absolutePos),!K.negTotal&&et(K.absoluteNeg)&&b(K,"absoluteNeg")&&(K.negTotal=K.absoluteNeg,delete K.absoluteNeg)),ot.isSum||(K.connectorThreshold=K.threshold+K.stackTotal),Z.reversed?(U=dt>=0?F-dt:F+dt,q=F):(U=F,q=F-dt),ot.below=U<=$,ht.y=Z.translate(U,!1,!0,!1,!0),ht.height=Math.abs(ht.y-Z.translate(q,!1,!0,!1,!0));let _=Z.waterfall.dummyStackItem;_&&(_.x=V,_.label=st[V].label,_.setOffset((this||G).pointXOffset||0,(this||G).barW||0,(this||G).stackedYNeg[V],(this||G).stackedYPos[V],void 0,(this||G).xAxis))}}else F=Math.max(rt,rt+dt)+pt[0],ht.y=Z.translate(F,!1,!0,!1,!0),ot.isSum?(ht.y=Z.translate(pt[1],!1,!0,!1,!0),ht.height=Math.min(Z.translate(pt[0],!1,!0,!1,!0),Z.len)-ht.y,ot.below=pt[1]<=$):ot.isIntermediateSum?(dt>=0?(U=pt[1]+at,q=at):(U=at,q=pt[1]+at),Z.reversed&&(U^=q,q^=U,U^=q),ht.y=Z.translate(U,!1,!0,!1,!0),ht.height=Math.abs(ht.y-Math.min(Z.translate(q,!1,!0,!1,!0),Z.len)),at+=pt[1],ot.below=U<=$):(ht.height=nt>0?Z.translate(rt,!1,!0,!1,!0)-ht.y:Z.translate(rt,!1,!0,!1,!0)-Z.translate(rt-nt,!1,!0,!1,!0),rt+=nt,ot.below=rt<$),ht.height<0&&(ht.y+=ht.height,ht.height*=-1);ot.plotY=ht.y=Math.round(ht.y||0)-(this||G).borderWidth%2/2,ht.height=Math.max(Math.round(ht.height||0),.001),ot.yBottom=ht.y+ht.height,ht.height<=_&&!ot.isNull?(ht.height=_,ht.y-=Q,ot.plotY=ht.y,ot.minPointLengthOffset=dt<0?-Q:Q):(ot.isNull&&(ht.width=0),ot.minPointLengthOffset=0);let ct=ot.plotY+(ot.negative?ht.height:0);ot.below&&(ot.plotY+=ht.height),ot.tooltipPos&&((this||G).chart.inverted?ot.tooltipPos[0]=Z.len-ct:ot.tooltipPos[1]=ct),ot.isInside=this.isPointInside(ot),it(!0,ot.shapeArgs,ht)}}),{order:2}),F.registerSeriesType("waterfall",m),m})),i(H,"masters/highcharts-more.src.js",[H["Core/Globals.js"],H["Core/Series/SeriesRegistry.js"],H["Extensions/Pane/Pane.js"],H["Series/Bubble/BubbleSeries.js"],H["Series/PackedBubble/PackedBubbleSeries.js"],H["Series/PolarComposition.js"],H["Series/Waterfall/WaterfallSeries.js"]],(function(G,F,H,U,q,V,K){U.compose(G.Axis,G.Chart,G.Legend,G.Series),q.compose(G.Axis,G.Chart,G.Legend,G.Series),H.compose(G.Chart,G.Pointer),V.compose(G.Axis,G.Chart,G.Pointer,G.Series,G.Tick,G.Point,F.seriesTypes.areasplinerange,F.seriesTypes.column,F.seriesTypes.line,F.seriesTypes.spline),K.compose(G.Axis,G.Chart)}))}));var H=F;export{H as default};

